<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[selenium 截长图]]></title>
      <url>%2F2019%2F04%2F21%2Fselenium-%E6%88%AA%E9%95%BF%E5%9B%BE%2F</url>
      <content type="text"><![CDATA[一、问题概述在用selenium爬取网站的时候，有的时候需要截图保存为png图片，但是selenium截图和一般的qq、微信截图一样，只能截取当前可见区域的，也就是你的屏幕上可视区域，超出屏幕区域就无法截取。但是我们有的时候需要截取一整个element的图片，而这个element已经超出了屏幕，需要上下滑动才能看的见整个element，或者说我们想要截取的图片已经超出了屏幕，需要上下滑动，selenium自带的截图方法就无法实现。 二、解决思路 要想实现这个功能，需要注意以下几点 首先你需要滚动滑动条，把想要截取的部分滚动到可视区域才能截取 计算整个你要截取的element的高度,分区域截图,边滑动边截图,截取多张图 吧多张截取的图片合并成一张图片,就是你想要的长截图三、实现过程这里最难的恐怕就是上面的第二点了,怎么计算这个高度,分部截取图片 1、首先找到你要截取的element，计算当前总高度和可视高度123456String js_scroll = &quot;return document.body.scrollHeight&quot;;long totalHeight = (Long) ((JavascriptExecutor) driver) .executeScript(js_scroll);// 获得webElement的位置和大小。Point location = webElement.getLocation();Dimension size = webElement.getSize(); 2、创建全屏截图，即可见区域截图,第一张截图123456789// 创建全屏截图。BufferedImage originalImage = ImageIO. read( new ByteArrayInputStream( takeScreenshot(driver)));int viewHeight = originalImage.getHeight();// 截取webElement所在位置的子图。BufferedImage croppedImage = originalImage.getSubimage(location.getX(), location.getY(), size.getWidth(), viewHeight - location.getY());ImageIO. write(croppedImage, &quot;png&quot;, new File(dir + &quot;0.png&quot; )); 3、计算滑动距离，每次滑动100，从第一张截图的最末尾向下计算100的高度，截取100的高度（这里每次滑动距离100可以自行修改）先截全屏,然后裁剪100的高度123456789101112131415161718192021222324252627282930313233343536if (viewHeight &lt; size. height + location. getY()) &#123; // 需要滑动的距离 int sHeight = size.height - (( int) viewHeight - location.getY()); int i = 0; int h = 0; while (h &lt; sHeight) &#123; i += 1; h = i * 100; if (h - sHeight &lt; 100 &amp;&amp; h - sHeight &gt; 0) &#123; ((JavascriptExecutor) driver).executeScript( &quot;window.scrollBy(0, &quot; + (100 - (h - sHeight)) + &quot;)&quot; ); &#125; else &#123; ((JavascriptExecutor) driver) .executeScript( &quot;window.scrollBy(0, 100)&quot; ); &#125; try &#123;// 最好等一下，不然太快错乱，有的时候需要等待 Thread. sleep(2 * 1000); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; // 创建全屏截图。 BufferedImage originalImage2 = ImageIO . read( new ByteArrayInputStream(takeScreenshot(driver))); BufferedImage croppedImage2; if (h - sHeight &lt; 100 &amp;&amp; h - sHeight &gt; 0) &#123; // 截取webElement所在位置的子图。 croppedImage2 = originalImage2.getSubimage(location.getX(),( int ) (viewHeight - (100 - (h - sHeight))), size.getWidth(), 100 - (h - sHeight)); &#125; else &#123; // 截取webElement所在位置的子图。 croppedImage2 = originalImage2.getSubimage(location.getX(), ( int ) (viewHeight - 100), size.getWidth(), 100); &#125; ImageIO. write(croppedImage2, &quot;png&quot;, new File(dir + i + &quot;.png&quot; )); &#125; &#125; 4、合并所截取的图片123456789101112131415161718192021222324252627282930313233343536373839/** * 合成多张图片 * * @param dir * 图片文件夹，里面是1. png,2.png * @param newFilename * 新的文件名 * @throws IOException */ private static void mergePic(String dir, String newFilename) throws IOException &#123; File[] pics = new File(dir).listFiles(); int h = 0; int w = 0; for (File p : pics) &#123; // 读取文件 BufferedImage b = ImageIO. read(p); h += b.getHeight(); w = b.getWidth(); &#125; BufferedImage bi = new BufferedImage(w, h, BufferedImage. TYPE_4BYTE_ABGR ); int yy = 0; for (int i = 0; i &lt; pics. length; i++) &#123; // 读取文件 BufferedImage b = ImageIO. read( new File(dir + i + &quot;.png&quot; )); for (int y = 0; y &lt; b.getHeight(); y++) &#123; for (int x = 0; x &lt; w; x++) &#123; bi.setRGB(x, y + yy, b.getRGB(x, y)); &#125; &#125; yy += b.getHeight(); &#125; // 输出文件 try &#123; ImageIO. write(bi, &quot;PNG&quot;, new File(dir + newFilename)); &#125; catch (IOException ex) &#123; &#125; &#125; 四、完整java实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117/** * 定位截取长图 滑动，截多张图 * * @param driver * @param webElement * @param dir * @throws IOException */ private static void takeAll(WebDriver driver, WebElement webElement, String dir) throws IOException &#123; // 获取可见高度 // String js_view = &quot;return window.innerHeight&quot;; // long viewHeight = (Long) ((JavascriptExecutor) driver) // .executeScript(js_view); String js_scroll = &quot;return document.body.scrollHeight&quot;; long totalHeight = (Long) ((JavascriptExecutor) driver) .executeScript(js_scroll); // 获得webElement的位置和大小。 Point location = webElement.getLocation(); Dimension size = webElement.getSize(); // 创建全屏截图。 BufferedImage originalImage = ImageIO. read( new ByteArrayInputStream( takeScreenshot(driver))); int viewHeight = originalImage.getHeight(); // 截取webElement所在位置的子图。 BufferedImage croppedImage = originalImage.getSubimage(location.getX(), location.getY(), size.getWidth(), viewHeight - location.getY()); ImageIO. write(croppedImage, &quot;png&quot;, new File(dir + &quot;0.png&quot; )); if (viewHeight &lt; size. height + location. getY()) &#123; // 需要滑动的距离 int sHeight = size.height - (( int) viewHeight - location.getY()); int i = 0; int h = 0; while (h &lt; sHeight) &#123; i += 1; h = i * 100; if (h - sHeight &lt; 100 &amp;&amp; h - sHeight &gt; 0) &#123; ((JavascriptExecutor) driver) .executeScript( &quot;window.scrollBy(0, &quot; + (100 - (h - sHeight)) + &quot;)&quot; ); &#125; else &#123; ((JavascriptExecutor) driver) .executeScript( &quot;window.scrollBy(0, 100)&quot; ); &#125; try &#123;// 最好等一下，不然太快错乱，有的时候需要等待 Thread. sleep(2 * 1000); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; // 创建全屏截图。 BufferedImage originalImage2 = ImageIO . read( new ByteArrayInputStream(takeScreenshot(driver))); BufferedImage croppedImage2; if (h - sHeight &lt; 100 &amp;&amp; h - sHeight &gt; 0) &#123; // 截取webElement所在位置的子图。 croppedImage2 = originalImage2.getSubimage(location.getX(), ( int ) (viewHeight - (100 - (h - sHeight))), size.getWidth(), 100 - (h - sHeight)); &#125; else &#123; // 截取webElement所在位置的子图。 croppedImage2 = originalImage2.getSubimage(location.getX(), ( int ) (viewHeight - 100), size.getWidth(), 100); &#125; ImageIO. write(croppedImage2, &quot;png&quot;, new File(dir + i + &quot;.png&quot; )); &#125; &#125; &#125;/** * 合成多张图片 * * @param dir * 图片文件夹，里面是1. png,2.png * @param newFilename * 新的文件名 * @throws IOException */ private static void mergePic(String dir, String newFilename) throws IOException &#123; File[] pics = new File(dir).listFiles(); int h = 0; int w = 0; for (File p : pics) &#123; // 读取文件 BufferedImage b = ImageIO. read(p); h += b.getHeight(); w = b.getWidth(); &#125; BufferedImage bi = new BufferedImage(w, h, BufferedImage. TYPE_4BYTE_ABGR ); int yy = 0; for (int i = 0; i &lt; pics. length; i++) &#123; // 读取文件 BufferedImage b = ImageIO. read( new File(dir + i + &quot;.png&quot; )); for (int y = 0; y &lt; b.getHeight(); y++) &#123; for (int x = 0; x &lt; w; x++) &#123; bi.setRGB(x, y + yy, b.getRGB(x, y)); &#125; &#125; yy += b.getHeight(); &#125; // 输出文件 try &#123; ImageIO. write(bi, &quot;PNG&quot;, new File(dir + newFilename)); &#125; catch (IOException ex) &#123; &#125; &#125; main函数里面调用123takeAll(driver, driver.findElement(By.className( &quot;main-content&quot;)), &quot;C:\\Users\\Administrator\\Desktop\\66\\&quot; );mergePic( &quot;C:\\Users\\Administrator\\Desktop\\66\\&quot;, &quot;a.png&quot; ); 五、顺便附上Python版的代码(感兴趣的可以看下)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import sysfrom selenium import webdriverimport utilimport osimport timefrom PIL import Imagedef fullpage_screenshot(driver, file): print(&quot;Starting chrome full page screenshot workaround ...&quot;) total_width = driver.execute_script(&quot;return document.body.offsetWidth&quot;) total_height = driver.execute_script(&quot;return document.body.parentNode.scrollHeight&quot;) viewport_width = driver.execute_script(&quot;return document.body.clientWidth&quot;) viewport_height = driver.execute_script(&quot;return window.innerHeight&quot;) print(&quot;Total: (&#123;0&#125;, &#123;1&#125;), Viewport: (&#123;2&#125;,&#123;3&#125;)&quot;.format(total_width, total_height,viewport_width,viewport_height)) rectangles = [] i = 0 while i &lt; total_height: ii = 0 top_height = i + viewport_height if top_height &gt; total_height: top_height = total_height while ii &lt; total_width: top_width = ii + viewport_width if top_width &gt; total_width: top_width = total_width print(&quot;Appending rectangle (&#123;0&#125;,&#123;1&#125;,&#123;2&#125;,&#123;3&#125;)&quot;.format(ii, i, top_width, top_height)) rectangles.append((ii, i, top_width,top_height)) ii = ii + viewport_width i = i + viewport_height stitched_image = Image.new(&apos;RGB&apos;, (total_width, total_height)) previous = None part = 0 for rectangle in rectangles: if not previous is None: driver.execute_script(&quot;window.scrollTo(&#123;0&#125;, &#123;1&#125;)&quot;.format(rectangle[0], rectangle[1])) time.sleep(0.2) driver.execute_script(&quot;document.getElementById(&apos;topnav&apos;).setAttribute(&apos;style&apos;, &apos;position: absolute; top: 0px;&apos;);&quot;) time.sleep(0.2) print(&quot;Scrolled To (&#123;0&#125;,&#123;1&#125;)&quot;.format(rectangle[0], rectangle[1])) time.sleep(0.2) file_name = &quot;part_&#123;0&#125;.png&quot;.format(part) print(&quot;Capturing &#123;0&#125; ...&quot;.format(file_name)) driver.get_screenshot_as_file(file_name) screenshot = Image.open(file_name) if rectangle[1] + viewport_height &gt; total_height: offset = (rectangle[0], total_height - viewport_height) else: offset = (rectangle[0], rectangle[1]) print(&quot;Adding to stitched image with offset (&#123;0&#125;, &#123;1&#125;)&quot;.format(offset[0],offset[1])) stitched_image.paste(screenshot, offset) del screenshot os.remove(file_name) part = part + 1 previous = rectangle stitched_image.save(file) print(&quot;Finishing chrome full page screenshot workaround...&quot;) return Truedriver = webdriver.Chrome()&apos;&apos;&apos; Generate document-height screenshot &apos;&apos;&apos;# url = &quot;http://effbot.org/imagingbook/introduction.htm&quot;url = &quot;http://www.w3schools.com/js/default.asp&quot;driver.get(url)fullpage_screenshot(driver, &quot;test1236.png&quot;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[tensorflow手写识别]]></title>
      <url>%2F2018%2F08%2F29%2Ftensorflow%E6%89%8B%E5%86%99%E8%AF%86%E5%88%AB%2F</url>
      <content type="text"><![CDATA[使用Tensorflow和MNIST识别自己手写的数字这里主要是利用CNN算法来训练Google提供的MNIST_data数据，然后保存模型，然后利用模型来测试识别图片数字 Tensorflow和MNIST简介TensorFlow™ 是一个采用数据流图，用于数值计算的开源软件库。它是一个不严格的“神经网络”库，可以利用它提供的模块搭建大多数类型的神经网络。它可以基于ＣＰＵ或ＧＰＵ运行，可以自动使用ＧＰＵ，无需编写分配程序。 MNIST是一个巨大的手写数字数据集，被广泛应用于机器学习识别领域。MNIST有60000张训练集数据和10000张测试集数据，每一个训练元素都是28*28像素的手写数字图片。作为一个常见的数据集，MNIST经常被用来测试神经网络，也是比较基本的应用。 CNN算法识别算法主要使用的是卷积神经网络算法（CNN）。 主要结构为：输入-卷积层-池化层-卷积层-池化层-全连接层-输出 卷积卷积其实可以看做是提取特征的过程。如果不使用卷积的话，整个网络的输入量就是整张图片，处理就很困难。 假设图中绿色55矩阵为原图片，黄色的33矩阵就是我们的过滤器，即卷积核。将黄色矩阵和绿色矩阵被覆盖的部分进行卷积计算，即每个元素相乘求和，便可得到这一部分的特征值，即图中的卷积特征。然后，向右滑动黄色的矩阵，便可继续求下一部分的卷积特征值。而滑动的距离就是步长。 池化池化是用来把卷积结果进行压缩，进一步减少全连接时的连接数。 池化有两种：一种是最大池化，在选中区域中找最大的值作为抽样后的值；一种是平均值池化，把选中的区域中的平均值作为抽样后的值。 实现过程1.训练程序,保存模型这里我就先把程序贴出来，主体和tensorflow教程上大致相同。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394from tensorflow.examples.tutorials.mnist import input_dataimport tensorflow as tf# 训练模型mnist = input_data.read_data_sets(&apos;MNIST_data&apos;, one_hot=True)sess = tf.InteractiveSession()x = tf.placeholder(tf.float32, shape=[None, 784])y_ = tf.placeholder(tf.float32, shape=[None, 10])W = tf.Variable(tf.zeros([784, 10]))b = tf.Variable(tf.zeros([10]))sess.run(tf.global_variables_initializer())y = tf.matmul(x, W) + bcross_entropy = tf.reduce_mean( tf.nn.softmax_cross_entropy_with_logits(labels=y_, logits=y))train_step = tf.train.GradientDescentOptimizer(0.5).minimize(cross_entropy)for _ in range(1000): batch = mnist.train.next_batch(100) train_step.run(feed_dict=&#123;x: batch[0], y_: batch[1]&#125;)correct_prediction = tf.equal(tf.argmax(y, 1), tf.argmax(y_, 1))accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))print(accuracy.eval(feed_dict=&#123;x: mnist.test.images, y_: mnist.test.labels&#125;))def weight_variable(shape): initial = tf.truncated_normal(shape, stddev=0.1) return tf.Variable(initial)def bias_variable(shape): initial = tf.constant(0.1, shape=shape) return tf.Variable(initial)def conv2d(x, W): return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding=&apos;SAME&apos;)def max_pool_2x2(x): return tf.nn.max_pool(x, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding=&apos;SAME&apos;)W_conv1 = weight_variable([5, 5, 1, 32])b_conv1 = bias_variable([32])x_image = tf.reshape(x, [-1, 28, 28, 1])h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)h_pool1 = max_pool_2x2(h_conv1)W_conv2 = weight_variable([5, 5, 32, 64])b_conv2 = bias_variable([64])h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)h_pool2 = max_pool_2x2(h_conv2)W_fc1 = weight_variable([7 * 7 * 64, 1024])b_fc1 = bias_variable([1024])h_pool2_flat = tf.reshape(h_pool2, [-1, 7 * 7 * 64])h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)keep_prob = tf.placeholder(tf.float32)h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)W_fc2 = weight_variable([1024, 10])b_fc2 = bias_variable([10])y_conv = tf.matmul(h_fc1_drop, W_fc2) + b_fc2cross_entropy = tf.reduce_mean( tf.nn.softmax_cross_entropy_with_logits(labels=y_, logits=y_conv))train_step = tf.train.AdamOptimizer(1e-4).minimize(cross_entropy)correct_prediction = tf.equal(tf.argmax(y_conv, 1), tf.argmax(y_, 1))accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))saver = tf.train.Saver() # defaults to saving all variablessess.run(tf.global_variables_initializer())for i in range(20000): batch = mnist.train.next_batch(50) if i % 100 == 0: train_accuracy = accuracy.eval(feed_dict=&#123; x: batch[0], y_: batch[1], keep_prob: 1.0&#125;) print(&quot;step %d, training accuracy %g&quot; % (i, train_accuracy)) train_step.run(feed_dict=&#123;x: batch[0], y_: batch[1], keep_prob: 0.5&#125;)saver.save(sess, &quot;./model/ckpt.model&quot;) # 保存模型参数，注意把这里改为自己的路径print(&quot;test accuracy %g&quot; % accuracy.eval(feed_dict=&#123; x: mnist.test.images, y_: mnist.test.labels, keep_prob: 1.0&#125;)) 训练好了网络，下一步就要测试它了。这里我们用Google提供的训练数据，我们把二进制文件转换为图片 这里是代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859from PIL import Imageimport struct# 解析mnist图片def read_image(filename): f = open(filename, &apos;rb&apos;) index = 0 buf = f.read() f.close() magic, images, rows, columns = struct.unpack_from(&apos;&gt;IIII&apos;, buf, index) index += struct.calcsize(&apos;&gt;IIII&apos;) for i in range(images): # for i in xrange(2000): image = Image.new(&apos;L&apos;, (columns, rows)) for x in range(rows): for y in range(columns): image.putpixel((y, x), int(struct.unpack_from(&apos;&gt;B&apos;, buf, index)[0])) index += struct.calcsize(&apos;&gt;B&apos;) print(&apos;save &apos; + str(i) + &apos;image&apos;) image.save(&apos;./image/test/&apos; + str(i) + &apos;.png&apos;)def read_label(filename, saveFilename): f = open(filename, &apos;rb&apos;) index = 0 buf = f.read() f.close() magic, labels = struct.unpack_from(&apos;&gt;II&apos;, buf, index) index += struct.calcsize(&apos;&gt;II&apos;) labelArr = [0] * labels # labelArr = [0] * 2000 for x in range(labels): # for x in xrange(2000): labelArr[x] = int(struct.unpack_from(&apos;&gt;B&apos;, buf, index)[0]) index += struct.calcsize(&apos;&gt;B&apos;) save = open(saveFilename, &apos;w&apos;) save.write(&apos;,&apos;.join(map(lambda x: str(x), labelArr))) save.write(&apos;\n&apos;) save.close() print(&apos;save labels success&apos;)if __name__ == &apos;__main__&apos;: read_image(&apos;MNIST_data/t10k-images.idx3-ubyte&apos;) read_label(&apos;MNIST_data/t10k-labels.idx1-ubyte&apos;, &apos;./image/test/label.txt&apos;) 转换完后得到的图片: 这里我们也可以自己写一位数字图片，然后利用opencv把图片处理成28*28像素的，并转变为灰度图，进行二值化处理。列如这样的照片: 完成预处理程序后，我们得到了这样的图片： 将图片输入网络进行识别这里我是编写了一个前向传播的程序，最后softmax层分类的结果就是最后的识别结果啦。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109from PIL import Image, ImageFilterimport tensorflow as tfimport matplotlib.pyplot as pltimport cv2.cv2 as cv2# 模型测试 识别图片 图片一定是28*28的def imageprepare(): &quot;&quot;&quot; This function returns the pixel values. The imput is a png file location. &quot;&quot;&quot; file_name = &apos;image/test/5.png&apos; # 导入自己的图片地址 # in terminal &apos;mogrify -format png *.jpg&apos; convert jpg to png im = Image.open(file_name).convert(&apos;L&apos;) im.save(&quot;image/sample.png&quot;) plt.imshow(im) plt.show() tv = list(im.getdata()) # get pixel values print(tv) # normalize pixels to 0 and 1. 0 is pure white, 1 is pure black. # 这里如果图片数字是黑的 背景是白的 tva = [(250-x) * 1.0 / 255.0 for x in tv] tva = [(x) * 1.0 / 255.0 for x in tv] print(tva) return tva &quot;&quot;&quot; This function returns the predicted integer. The imput is the pixel values from the imageprepare() function. &quot;&quot;&quot; # Define the model (same as when creating the model file)result = imageprepare()x = tf.placeholder(tf.float32, [None, 784])W = tf.Variable(tf.zeros([784, 10]))b = tf.Variable(tf.zeros([10]))def weight_variable(shape): initial = tf.truncated_normal(shape, stddev=0.1) return tf.Variable(initial)def bias_variable(shape): initial = tf.constant(0.1, shape=shape) return tf.Variable(initial)def conv2d(x, W): return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding=&apos;SAME&apos;)def max_pool_2x2(x): return tf.nn.max_pool(x, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding=&apos;SAME&apos;)W_conv1 = weight_variable([5, 5, 1, 32])b_conv1 = bias_variable([32])x_image = tf.reshape(x, [-1, 28, 28, 1])h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1)h_pool1 = max_pool_2x2(h_conv1)W_conv2 = weight_variable([5, 5, 32, 64])b_conv2 = bias_variable([64])h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2)h_pool2 = max_pool_2x2(h_conv2)W_fc1 = weight_variable([7 * 7 * 64, 1024])b_fc1 = bias_variable([1024])h_pool2_flat = tf.reshape(h_pool2, [-1, 7 * 7 * 64])h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1)keep_prob = tf.placeholder(tf.float32)h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob)W_fc2 = weight_variable([1024, 10])b_fc2 = bias_variable([10])y_conv = tf.nn.softmax(tf.matmul(h_fc1_drop, W_fc2) + b_fc2)init_op = tf.initialize_all_variables()&quot;&quot;&quot;Load the model2.ckpt filefile is stored in the same directory as this python script is startedUse the model to predict the integer. Integer is returend as list.Based on the documentatoin athttps://www.tensorflow.org/versions/master/how_tos/variables/index.html&quot;&quot;&quot;saver = tf.train.Saver()with tf.Session() as sess: sess.run(init_op) saver.restore(sess, &quot;./model/ckpt.model&quot;) # 这里使用了之前保存的模型参数 # print (&quot;Model restored.&quot;) prediction = tf.argmax(y_conv, 1) predint = prediction.eval(feed_dict=&#123;x: [result], keep_prob: 1.0&#125;, session=sess) print(h_conv2) print(&apos;recognize result:&apos;) print(predint[0])]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scrapy 爬取亚马逊信息]]></title>
      <url>%2F2018%2F04%2F16%2Fscrapy-%E7%88%AC%E5%8F%96%E4%BA%9A%E9%A9%AC%E9%80%8A%E4%BF%A1%E6%81%AF%2F</url>
      <content type="text"><![CDATA[一、安装scrapy这里不多说，查找网上教程自行安装就行 二、爬取目的 因为最近有个需求是检测Amazon网站的两个店铺所卖的东西，所以这里主要是拿取店铺里面产品的ASIN单号 三、开始爬虫1、输入命令创建项目，（这里有一些命令，大家可以输入scrapy查看命令 ，这里不多说）1scrapy startproject Amazon 2、默认文件功能命令输入完成后，会相应生成一些文件，如下： spider文件夹主要是放置你的爬虫文件的。 item.py主要是用来自定义类,然后声明一些你要爬取的字段信息。 middlewares.py中间件,Spider中间件是介入到Scrapy的spider处理机制的钩子框架，您可以添加代码来处理发送给 Spiders的response及spider产生的item和request。这里可以设置代理ip等。 pipelines.py 这里主要是处理item信息的。 当Item在Spider中被收集之后，它将会被传递到Item Pipeline，一些组件会按照一定的顺序执行对Item的处理。 setting.py Scrapy设定(settings)提供了定制Scrapy组件的方法。您可以控制包括核心(core)，插件(extension)，pipeline及spider组件。设定为代码提供了提取以key-value映射的配置值的的全局命名空间(namespace)。 设定可以通过下面介绍的多种机制进行设置。设定(settings)同时也是选择当前激活的Scrapy项目的方法(如果您有多个的话)。内置设定列表请参考 内置设定参考手册 。 以下是item pipeline的一些典型应用： • 清理HTML数据 • 验证爬取的数据(检查item包含某些字段) • 查重(并丢弃) • 将爬取结果保存到数据库中 3、编写代码首先在spider文件夹里面创建爬虫文件,我们这里有两个店铺需要爬取,我先写uk这个店铺的,创建uk_amazon_spider.py123456789101112131415161718192021class UkAmazonSpider(scrapy.Spider): name = &apos;ukamazonspider&apos; # allowed_domains = [&quot;amazon&quot;] start_urls = [ &apos;https://www.amazon.co.uk/s?marketplaceID=A1F83G8C2ARO7P&amp;me=ANZYLS5IXG3VI&amp;merchant=ANZYLS5IXG3VI&amp;redirect=true&apos;] def parse(self, response): anis_list = response.xpath(&quot;//li/div[@class=&apos;s-item-container&apos;]&quot;) for anis in anis_list: item = UkPipelineItem() anis_link = anis.xpath(&quot;./div[3]/div[1]/a/@href&quot;).extract()[0] item[&quot;uk_anis&quot;] = anis_link.split(&apos;/dp/&apos;)[1].split(&apos;/&apos;)[0] if len(anis.xpath(&quot;.//div[@class=&apos;a-box-inner a-padding-mini&apos;]&quot;)) &gt; 0: print(&apos;more&apos;) yield scrapy.Request(anis_link, callback=self.parse_more) yield item if len(response.xpath(&quot;//a[@id=&apos;pagnNextLink&apos;]&quot;)) &gt; 0: next_url = response.xpath(&quot;//a[@id=&apos;pagnNextLink&apos;]/@href&quot;).extract()[0] print(next_url) yield scrapy.Request(&quot;https://www.amazon.co.uk&quot; + next_url, callback=self.parse) name: 用于区别Spider。 该名字必须是唯一的，您不可以为不同的Spider设定相同的名字。 start_urls: 包含了Spider在启动时进行爬取的url列表。 因此，第一个被获取到的页面将是其中之一。 后续的URL则从初始的URL获取到的数据中提取。 parse() 是spider的一个方法。 被调用时，每个初始URL完成下载后生成的 Response 对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成item)以及生成需要进一步处理的URL的 Request 对象。 allowed_domains 这里是爬取网站的域名,可选项 打开我们的起始页,我们发现我们要的asin单号其实在我们产品链接里面的,那么我们首先要拿到这里的链接才行,其实我们也可以点开这个连接进入到另一个页面获取,但是这里直接在连接里面提取更快。我们通过小path提取当前页面的所有产品详情url，然后循环提取其中的anis_link,拿到里面的anis后传给item。这里我们发现有的产品可能有多个颜色的选择，它的每个颜色的anis单号不一样，所以我们要获取这个产品的url，进入到这个产品的页面去获取其他颜色的anis单号。需要多写个方法yield scrapy.Request(anis_link, callback=self.parse_more)，记住这里要用yield，不要return。1234567891011@classmethod def parse_more(self, response): # 拿更多的 data_asin = response.xpath(&quot;//div[@id=&apos;variation_color_name&apos;]/ul/li&quot;) if data_asin is None: return for data in data_asin: item = UkPipelineItem() dataa = data.xpath(&quot;./@data-defaultasin&quot;).extract()[0] item[&quot;uk_anis&quot;] = dataa + &quot;-more&quot; yield item 通过xpath定位元素，然后传给item就行，至于如何使用xpath，这里不多做阐述。 好吧，我们拿到了第一个页面的所有anis单号，但是这里我们有十几个页面需要去拿，涉及到翻页。我们发现其实下一页的链接都存在下一页的按钮中，我们只需要爬取每一夜的时候拿到这个链接并把它加入到我们的请求中去就行了。但是回调函数还是当前的这个方法，因为每个页面的解析都一样。1234if len(response.xpath(&quot;//a[@id=&apos;pagnNextLink&apos;]&quot;)) &gt; 0: next_url = response.xpath(&quot;//a[@id=&apos;pagnNextLink&apos;]/@href&quot;).extract()[0] print(next_url) yield scrapy.Request(&quot;https://www.amazon.co.uk&quot; + next_url, callback=self.parse) 这里爬虫文件代码写完了，是不是很简单。 4、我们看下我们的item.py文件123class UkPipelineItem(scrapy.Item): # define the fields for your item here like: uk_anis = scrapy.Field() 很简单，因为我们只需要拿到anis单号就行 5、看下pipelines.py文件这里是处理item的，所以我们要把拿到的item写入到文件里，这里我们选择txt，如果你要拿的字段比较多的话，选择json比较好。 1234567891011class AmazonscrapyPipeline(object): def __init__(self): self.uk_file = open(&quot;txt/uk_amaozninfo.txt&quot;, &quot;w&quot;) def process_item(self, item, spider): self.uk_file.write(item[&quot;uk_anis&quot;] + &quot;\n&quot;) return item def close_spider(self, spider): self.uk_file.close() 这样其实我们的代码已经写完了，但是我们要在setting里面注册启用item pipeline才行 6、setting.py文件123ITEM_PIPELINES = &#123; &apos;AmazonScrapy.pipelines.AmazonscrapyPipeline&apos;: 300,&#125; 四、代理我们通过上面的代码已经可以拿到我们的信息了,但是这不是长久的,很可能被封ip,我们就需要代理了。首先我们需要在middlewares.py中间件里面自定义我们的中间件类，看代码。 123456789101112131415161718192021222324252627282930313233class ProxyMiddleware(object): &quot;&quot;&quot;Custom ProxyMiddleware.&quot;&quot;&quot; def __init__(self, ): self.ua_list = [ &quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&quot;, &quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)&quot;, &quot;Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&quot;, &quot;Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)&quot;, &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)&quot;, &quot;Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)&quot;, &quot;Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)&quot;, &quot;Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0&quot;, ] def get_ip(self, spider): urlip = &apos;http://dynamic.goubanjia.yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyb940cd4f310407e1189c.html&apos; s = requests.Session() # 设置重试次数 s.mount(&apos;http://&apos;, HTTPAdapter(max_retries=5)) s.mount(&apos;https://&apos;, HTTPAdapter(max_retries=5)) response = s.get(urlip, timeout=30) ip = response.content.strip() ip = str(ip, encoding=&apos;utf-8&apos;) return ip def process_request(self, request, spider): ua = random.choice(self.ua_list) request.headers.setdefault(&apos;User-Agent&apos;, ua) print(self.get_ip(spider)) request.meta[&quot;proxy&quot;] = &quot;http://&quot; + self.get_ip(spider) 我么设置了一些user header list，随机请求头，主要设置代理ip是在process_request这个方法里面，get_ip方法是获取代理ip的方法。同理我们要在setting里面启用这个中间件。 12345DOWNLOADER_MIDDLEWARES = &#123; &apos;scrapy.downloadermiddlewares.httpproxy.HttpProxyMiddleware&apos;: 100, &apos;AmazonScrapy.middlewares.ProxyMiddleware&apos;: 80, &apos;AmazonScrapy.middlewares.RedirectionMiddleware&apos;: 120,&#125; 后面的数字代表的优先级，数字越小代表优先级越高 我们代理设置完成了，但是为了防止被封我们还有一些东西要设置，同样在setting.py里面我们需要把robot协议设置为false,不遵守robot协议 12345# Obey robots.txt rulesROBOTSTXT_OBEY = False# 如果启用，Scrapy将记录所有在request(Cookie 请求头)发送的cookies及response接收到的cookies(Set-Cookie 接收头)。COOKIES_ENABLED = False 最后,我们写完了代码,通过命令启用爬虫就行了 1scrapy crawl ukamazonspider 看我的github代码，我写了两个爬虫文件，然后涉及到同时启用多个爬虫文件的方法，大家可以参考。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[android 打开相机实现连续拍照]]></title>
      <url>%2F2018%2F01%2F27%2Fandroid-%E6%89%93%E5%BC%80%E7%9B%B8%E6%9C%BA%E5%AE%9E%E7%8E%B0%E8%BF%9E%E7%BB%AD%E6%8B%8D%E7%85%A7%2F</url>
      <content type="text"><![CDATA[一、概述最近遇到一个需求，需要打开相机，然后连续拍几张照片把照片显示在界面上，上传至服务器。为什么要连续拍照，是因为领导觉得连续拍照比一张张的拍照要快，好吧。。。。想办法实现吧。 二、思路首先说的是，这里不采用自己写相机（太麻烦），直接打开系统相机，然后去获取照片。一开始想的很简单，不就是打开相机然后在onActivityResult()方法里面拿到照片的路径不就完了吗好，我们这里就来实现下： 1、新建布局文件12345678910111213141516171819202122&lt;? xml version= &quot;1.0&quot; encoding = &quot;utf-8&quot;?&gt;&lt; RelativeLayout xmlns:android =&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width= &quot;match_parent&quot; android:layout_height= &quot;match_parent&quot; android:orientation= &quot;vertical&quot; &gt; &lt;Button android:id =&quot;@+id/button1&quot; android:layout_width =&quot;match_parent&quot; android:layout_height =&quot;wrap_content&quot; android:layout_centerHorizontal =&quot;true&quot; android:text = &quot;拍照&quot; /&gt; &lt;GridView android:id =&quot;@+id/ryMain&quot; android:layout_width =&quot;match_parent&quot; android:layout_height =&quot;match_parent&quot; android:layout_below =&quot;@+id/button1&quot; android:numColumns =&quot;3&quot; &gt; &lt;/GridView &gt;&lt;/ RelativeLayout&gt; 2、 初始化View:123456789101112131415161718192021222324252627282930313233343536private Button bt ; private GridView gridView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super .onCreate(savedInstanceState); setContentView(R.layout. activity_main ); bt = (Button) findViewById(R.id. button1 ); gridView = ((GridView) findViewById(R.id.ryMain )); &#125; public void takeOnCamera() &#123; // 打开相机之前，记录时间1 systemTime1 = getSystemTime(); Intent intent = new Intent(); // 此处之所以诸多try catch，是因为各大厂商手机不确定哪个方法 try &#123; intent.setAction(MediaStore. INTENT_ACTION_STILL_IMAGE_CAMERA ); startActivityForResult(intent, REQUEST_SMALL ); &#125; catch (Exception e) &#123; try &#123; intent.setAction(MediaStore. ACTION_IMAGE_CAPTURE_SECURE ); startActivityForResult(intent, REQUEST_SMALL ); &#125; catch (Exception e1) &#123; try &#123; intent.se tAction(MediaStore. INTENT_ACTION_STILL_IMAGE_CAMERA_SECURE ); startActivityForResult(intent, REQUEST_SMALL ); &#125; catch (Exception ell) &#123; Toast .makeText (MainActivity.this , &quot;请从相册选择&quot; , Toast. LENGTH_SHORT ).show(); &#125; &#125; &#125; &#125; 3、添加事件打开相机123456789101112bt .setOnClickListener( new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // 打开相机拍照 takeOnCamera(); &#125;//打开相机ACTION_IMAGE_CAPTURE//打开相机拍照一次ACTION_IMAGE_CAPTURE_SECUREINTENT_ACTION_STILL_IMAGE_CAMERAINTENT_ACTION_STILL _IMAGE_CAMERA_SECURE 这个intent是隐式跳转的，有四个常量，第一个大家都很熟悉，就是打开相机拍一张照片完事，所以我们不选他，其它的是拍多张的,我们一个个来试下。先试下ACTION_IMAGE_CAPTURE_SECURE12345public void takeOnCamera() &#123; Intent intent = new Intent(); intent.setAction(MediaStore. ACTION_IMAGE_CAPTURE_SECURE ); startActivityForResult(intent, REQUEST_SMALL ); &#125; 在onActivityResult中我们得到返回值,打印log12345 @Override protected void onActivityResult( int requestCode, int resultCode, Intent data) &#123; Log. e( &quot;data&quot;, &quot;onActivityResult: &quot; + data); super .onActivityResult(requestCode, resultCode, data);&#125; 最后运行试下,发现打印出来的data为null,其它模式也不行,这里试过了。好吧,这种好像不行,但是看到图片路径:———getContentProvider: /storage/emulated/0/DCIM/Camera/IMG_20180125_103542.jpg,很熟悉,打开相册看下路径,明白了,要想拿到照片就得去相册里面拿。但是怎么拿，这里就需要用到内容提供者 ContentProvider这个了 好了，废话不多说，这里总结下： 内容提供者ContentProvider与内容接受者ContentResolver 数据库、多线程（这个可以忽略但是要知道，数据库 ，上一条已经把这个做好了，多线程是因为查数据库其实是耗时的，最好在子线程里面，避免ANR，咱这里就不提了） 路径转换出时间再转换成数字（时间格式转化，String类型转换成其他类型），记录开始拍照的时间和结束拍照的时间 筛选图片路径(正则表达式) 根据路径path找到图片 把图片压缩放后放到集合里面（二次采样） 三、拿取图片的代码1234567891011121314@Override protected void onActivityResult( int requestCode, int resultCode, Intent data) &#123; Log. e( &quot;data&quot;, &quot;onActivityResult: &quot; + data); // 关闭相机之后获得时间；2； pb.setVisibility(View. VISIBLE ); systemTime2 = getSystemTime(); if (requestCode == REQUEST_SMALL ) &#123; // 这里可以拓展不同按钮，给下面的方法传不同的参数 getContactList(); &#125; super .onActivityResult(requestCode, resultCode, data); &#125; 1234567891011121314151617181920212223242526272829303132333435private void getContactList() &#123; // 读取照片然后选择合适的照片保存再list里面 final String[] projection = &#123; MediaStore.Images.Media._ID , MediaStore.Images.Media. DISPLAY_NAME , MediaStore.Images.Media. DATA &#125;; final String orderBy = MediaStore.Images.Media.DISPLAY_NAME ; final Uri uri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI ; new Thread(new Runnable() &#123; @Override public void run() &#123; List&lt;MyBitmap&gt; list2 = getContentProvider(uri, projection, orderBy); // 到时候抽取接口 Log. e( &quot;list&quot;, &quot;call: &quot; + list2.toString() + &quot;.size&quot; + list2.size()); if (list2 != null) &#123; if (list2.size() &gt; 7) &#123;// 这里看要求最多几张照片 list2 = list2.subList(list2.size() - 7, list2.size()); &#125; final List&lt;MyBitmap&gt; finalList = list2; gridView.post( new Runnable() &#123; @Override public void run() &#123; // TODO 拿到数据源然后拓展 gridView.setAdapter( new Myadapter( MainActivity. this , finalList));// 拿到了就可以搞了 pb.setVisibility(View. GONE ); &#125; &#125;); &#125; &#125; &#125;).start(); &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 获取ContentProvider * * @param projection * @param orderBy */ public List&lt;MyBitmap&gt; getContentProvider(Uri uri, String[] projection, String orderBy) &#123; // TODO Auto-generated method stub List&lt;MyBitmap&gt; lists = new ArrayList&lt;MyBitmap&gt;(); HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(); Cursor cursor = getContentResolver().query(uri, projection, null , null , orderBy); if (null == cursor) &#123; return null ; &#125; while (cursor.moveToNext()) &#123; Log. e( &quot;lengthpro&quot;, &quot;getContentProvider: &quot; + projection.length ); for (int i = 0; i &lt; projection. length; i++) &#123; String string = cursor.getString(i); if (string != null) &#123; int length = string.length(); String ss = null ; if (length &gt;= 30) &#123;// 根据实际路径得到的。大一点保险 ss = string.substring(length - 23, length); String substring = ss.substring(0, 4);// 大致判断一下是系统图片，后面严格塞选 String hen = ss.substring(12, 13); if (substring.equals(&quot;IMG_&quot; ) &amp;&amp; hen.equals(&quot;_&quot; )) &#123; String laststring = ss.substring(4, 19).replace( &quot;_&quot; , &quot;&quot; ); try &#123; long time = Long.valueOf(laststring) .longValue(); if (time &gt; systemTime1 &amp;&amp; time &lt;= systemTime2 ) &#123; set.add(string); &#125; &#125; catch (Exception e) &#123; Log. e( &quot;exception&quot;, &quot;getContentProvider: &quot; + e.toString()); &#125; &#125; &#125; &#125; &#125; &#125; for (String strings : set) &#123; Log. e( &quot;setsize&quot;, &quot;getContentProvider: &quot; + strings); try &#123; Bitmap bitmap = convertToBitmap(strings, 300, 300); MyBitmap myBitmap = new MyBitmap(strings, bitmap); lists.add(myBitmap); &#125; catch (Exception e) &#123; Log. e( &quot;exceptionee&quot;, &quot;getSystemTime: &quot; + e.toString()); &#125; &#125; return lists; &#125; 下面就简单了，根据路径拿到图片并且二次采样如下：123456789101112131415161718192021222324252627282930/** * 根据路径，二次采样并且压缩 * * @param filePath * 路径 * @param destWidth * 压缩到的宽度 * @param destHeight * 压缩到的高度 * @return */ public Bitmap convertToBitmap(String filePath, int destWidth, int destHeight) &#123; // 第一采样 BitmapFactory.Options options = new BitmapFactory.Options(); options. inJustDecodeBounds = true ; BitmapFactory. decodeFile(filePath, options); int outWidth = options.outWidth ; int outHeight = options.outHeight ; int sampleSize = 1; while ((outWidth / sampleSize &gt; destWidth) || (outHeight / sampleSize &gt; destHeight)) &#123; sampleSize *= 2; &#125; // 第二次采样 options. inJustDecodeBounds = false ; options. inSampleSize = sampleSize; options. inPreferredConfig = Bitmap.Config.RGB_565 ; return BitmapFactory.decodeFile(filePath, options); &#125; 这样数据源就有了可以设置到GridView的适配器里面啦最后奉上全部代码地址：Camera_MoreImage]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2018%2F01%2F25%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python识别验证码]]></title>
      <url>%2F2017%2F09%2F14%2Fpython%E8%AF%86%E5%88%AB%E9%AA%8C%E8%AF%81%E7%A0%81%2F</url>
      <content type="text"><![CDATA[一、探讨识别图形验证码可以说是做爬虫的必修课，涉及到计算机图形学，机器学习，机器视觉，人工智能等等高深领域……简单地说，计算机图形学的主要研究内容就是研究如何在计算机中表示图形、以及利用计算机进行图形的计算、处理和显示的相关原理与算法。图形通常由点、线、面、体等几何元素和灰度、色彩、线型、线宽等非几何属性组成。计算机涉及到的几何图形处理一般有 2维到n维图形处理，边界区分，面积计算，体积计算，扭曲变形校正。对于颜色则有色彩空间的计算与转换，图形上色，阴影，色差处理等等。 在破解验证码中需要用到的知识一般是 像素，线，面等基本2维图形元素的处理和色差分析。常见工具为： •支持向量机(SVM) •OpenCV •图像处理软件(Photoshop,Gimp…) •Python Image Library 二、工具1.Python pytesseract 库 pytesseract 是对 Tesseract-OCR 的一个封装，方便我们在 Python 中调用 Tesseract-OCR 引擎 pytesseract下载Pypi Page 2.Tesseract-OCR 开源识别引擎 Tesseract was originally developed at Hewlett-Packard Laboratories Bristol and at Hewlett-Packard Co, Greeley Colorado between 1985 and 1994, with some more changes made in 1996 to port to Windows, and some C++izing in 1998. In 2005 Tesseract was open sourced by HP. Since 2006 it is developed by Google. Github Page 3.Python PIL(2.)/Pillow(3.) 库 这两个库是 Python 关于图像处理的第三方库，其中 3.* 的版本要用 Pillow 库 三、安装1.Tesseract-OCR 源码编译：可参照官方Wiki windows：安装包可以在 Sourceforge 上下载，不过只有 3.02 版本的安装包,安装的时候有个语言选项,默认不安装,但是可以选择安装 Linux：以 Ubuntu 为例，在终端输入sudo apt-get tesseract-ocr即可进行安装 Mac： MacPorts sudo port install tesseract Homebrew brew install tesseract P.S.在windows上安装时，在 Target appended to the Path 这一步耗时较久，请耐心等候。 安装完成后，在命令行界面输入 tesseract 会出现以下提示： Usage:tesseract imagename outputbase [-l lang] [-psm pagesegmode] [configfile…] pagesegmode values are: 0 = Orientation and script detection (OSD) only. 1 = Automatic page segmentation with OSD. 2 = Automatic page segmentation, but no OSD, or OCR 3 = Fully automatic page segmentation, but no OSD. (Default) 4 = Assume a single column of text of variable sizes. 5 = Assume a single uniform block of vertically aligned text. 6 = Assume a single uniform block of text. 7 = Treat the image as a single text line. 8 = Treat the image as a single word. 9 = Treat the image as a single word in a circle. 10 = Treat the image as a single character. -l lang and/or -psm pagesegmode must occur before anyconfigfile. Single options: -v –version: version info –list-langs: list available languages for tesseract engine 则说明引擎安装成功。 2.virtualenv为了将 Python 主环境隔离开来，不影响第三方库之间的兼容性，我们可以利用 virtualenv 来搭建虚拟且独立的python环境，可以使每个项目环境与其他项目独立开来，保持环境的干净，解决包冲突问题。 可以通过 pip 和 easy_install 进行安装： easy_install virtualenv 或 pip install virtualenv 详细可参照使用virtualenv搭建独立的Python环境 3. PIL, Pillow, pytesseract这三个库都可以通过 pip 直接安装。 四、编程 终于来到了这一步。。。。 验证码识别的一般思路为： 1、图片降噪 2、图片切割 3、图像文本输出 1.图片降噪所谓降噪就是把不需要的信息通通去除，比如背景，干扰线，干扰像素等等，只剩下需要识别的文字，让图片变成2进制点阵最好。 对于彩色背景的验证码：每个像素都可以放在一个5维的空间里，这5个维度分别是，X,Y,R,G,B，也就是像素的坐标和颜色，在计算机图形学中，有很多种色彩空间，最常用的比如RGB，印刷用的CYMK，还有比较少见的HSL或者HSV，每种色彩空间的维度都不一样，但是可以通过公式互相转换。在RGB空间中不好区分颜色，可以把色彩空间转换为HSV或HSL。色彩空间参见 http://baike.baidu.com/view/3427413.htm 验证码图片7039.jpg: 1.1、导入Image包，打开图片：12from PIL import Imageim = Image.open(&apos;7039.jpg&apos;) 1.2、把彩色图像转化为灰度图像。RBG转化到HSI彩色空间，采用I分量：12imgry = im.convert(&apos;L&apos;) imgry.show() 灰度看起来是这样的： 1. 3、二值化处理二值化是图像分割的一种常用方法。在二值化图象的时候把大于某个临界灰度值的像素灰度设为灰度极大值，把小于这个值的像素灰度设为灰度极小值，从而实现二值化（一般设置为0-1）。根据阈值选取的不同，二值化的算法分为固定阈值和自适应阈值，这里选用比较简单的固定阈值。 把像素点大于阈值的设置,1，小于阈值的设置为0。生成一张查找表，再调用point()进行映射。注意:记住这个阈值threshold是可以根据实际情况调节的,大小自己调节哪种比较合适123456789threshold = 140table = []for i in range(256): if i &lt; threshold: table.append(0) else: table.append(1)out = imgry.point(table, &apos;1&apos;)out.show() 处理结果看起来是这样的： 利用OTSU法（大津阈值分割法）来计算这个阈值,这里只介绍单阈值算法代码如下:1234567891011121314151617import cv2import numpy as npfrom matplotlib import pyplot as plt image = cv2.imread(&quot;a.jpg&quot;)gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)plt.subplot(131), plt.imshow(image, &quot;gray&quot;)plt.title(&quot;source image&quot;), plt.xticks([]), plt.yticks([])plt.subplot(132), plt.hist(image.ravel(), 256)plt.title(&quot;Histogram&quot;), plt.xticks([]), plt.yticks([])ret1, th1 = cv2.threshold(gray, 0, 255, cv2.THRESH_OTSU) # 方法选择为THRESH_OTSUplt.subplot(133), plt.imshow(th1, &quot;gray&quot;)plt.title(&quot;OTSU,threshold is &quot; + str(ret1)), plt.xticks([]), plt.yticks([])plt.show()print(str(ret1)) 这里还有其他算法得到阈值,大家可以搜索图像二值化即可 2.图片切割识别验证码的重点和难点就在于能否成功分割字符，对于颜色相同又完全粘连的字符，比如google的验证码，目前是没法做到5%以上的识别率的。不过google的验证码基本上人类也只有30%的识别率。本文使用的验证码例子比较容易识别。可以不用切割，有关图片切割的方法参见这篇博客：http://www.cnblogs.com/apexchu/p/4231041.html 3.利用pytesser模块实现识别pytesser是谷歌OCR开源项目的一个模块，在python中导入这个模块即可将图片中的文字转换成文本。链接：https://code.google.com/p/pytesser/ pytesser 调用了 tesseract。在python中调用pytesser模块，pytesser又用tesseract识别图片中的文字。可以参考这个github项目 https://github.com/madmaze/pytesseract 示例代码代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import pytesseractimport requests#from PIL import ImageEnhancefrom PIL import Image# 由于都是数字# 对于识别成字母的 采用该表进行修正rep = &#123;&apos;O&apos;: &apos;0&apos;, &apos;I&apos;: &apos;1&apos;, &apos;L&apos;: &apos;1&apos;, &apos;Z&apos;: &apos;2&apos;, &apos;S&apos;: &apos;8&apos; &#125;# 二值化处理,threshold为阈值(自己调试哪种出色)def initTable(threshold=120): table = [] for i in range(256): if i &lt; threshold: table.append(0) else: table.append(1) return tabledef reconize(): # 根据url获取验证码 captcha_url=&quot;http://captcha.qq.com/getimage?aid=755049101&amp;rd=0.29258651419368853&quot; r = requests.get(captcha_url) with open(&apos;a.jpg&apos;, &apos;wb&apos;) as f: f.write(r.content) f.close() image = Image.open(&apos;a.jpg&apos;) # 去除黑色边框：不然无法识别(如果有黑色边框的话) img = image.convert(&apos;RGBA&apos;) # 转换为RGBA pix = img.load() # 转换为像素 for x in range(img.size[0]): # 处理上下黑边框，size[0]即图片长度 pix[x, 0] = pix[x, img.size[1] - 1] = (255, 255, 255, 255) for y in range(img.size[1]): # 处理左右黑边框，size[1]即图片高度 pix[0, y] = pix[img.size[0] - 1, y] = (255, 255, 255, 255) # # 灰度 image2 = img.convert(&apos;L&apos;) # image2.show() # 降噪 binaryImage = image2.point(initTable(), &apos;1&apos;) binaryImage.show() # 黑白 # enhancer = ImageEnhance.Contrast(image2) # binaryImage2 = enhancer.enhance(4) # binaryImage2.show() # tessdata_dir_config 这里就是你的Tesseract-OCR安装路径,如果没有可能会报错 tessdata_dir_config = &apos;--tessdata-dir &quot;C:/Program Files (x86)/Tesseract-OCR/tessdata&quot;&apos; vcode = pytesseract.image_to_string(binaryImage, lang=&apos;eng&apos;, config=tessdata_dir_config) # 中文 lang=&apos;chi_sim&apos;,英文lang=&apos;eng&apos; 可以不设置这个 # vcode = pytesseract.image_to_string(binaryImage2, lang=&apos;chi_sim&apos;, config=tessdata_dir_config) #这里可以做些最后的文本修复,提高下识别率 # text = vcode.strip() # text = text.upper() # for r in rep: # text = text.replace(r, rep[r]) print(vcode)if __name__ == &apos;__main__&apos;: reconize() 最后如果发现识别率还是不高,可以通过jtessboxeditor 样本训练来提高识别率 参考链接:http://www.cnblogs.com/zhongtang/p/5555950.html]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用pyinstaller 打包Python程序]]></title>
      <url>%2F2017%2F06%2F08%2Fpyinstaller-toexe%2F</url>
      <content type="text"><![CDATA[一、首先就是安装pyinstaller了,这里只说pip安装(因为方便)cmd命令行进入你安装的Python路径(比如我的是E:\python),最后进入到Scripts这个文件夹 最后输入 &gt; pip install pyinstaller 会提示安装成功 二、进pyinstaller官网查看发现目前支持Python2.7和Python3.3-Python3.5版本的Python程序,这里是官网访问Pyinstaller 三.pyinstaller命令的使用 参数 含义 -F 指定打包后只生成一个exe格式的文件 -D –onedir 创建一个目录，包含exe文件，但会依赖很多文件（默认选项） -c –console, –nowindowed 使用控制台，无界面(默认) -w –windowed, –noconsole 使用窗口，无控制台 -p 添加搜索路径，让其找到对应的库。 -i 改变生成程序的icon图标 例如: &gt; pyinstaller -c -F -p E:\python_workpace\PABank\lib E:\python_workpace\PABank\pabank.py pabank.py为main函数 的文件 运行成功后,在命令行可以看到生成的exe程序所在的目录,,例如E:\python\Scripts\dist 四、注意事项1.如果在执行命令是失败了,一般是缺少什么库文件,pip安装就行了2.在GUI编程的时候(PYQT5)一定要加这句,-p E:\Python\Lib\site-packages\PyQt5\Qt\bin 这句3.在运行exe文件时,如果提示加载动态库失败,安装下vc_redist.x64.exe这个vc++2015,可以去微软官网下载]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实现发送邮箱的几种方法]]></title>
      <url>%2F2017%2F04%2F22%2Fsend-email%2F</url>
      <content type="text"><![CDATA[以下为众多方法中的几种，后面继续补充。。。。。 一、telnet windows下使用cmd（命令行）发送邮件 1、windows开启telnet服务 打开控制面板，找到“打开或关闭windows功能”（在“程序”里面），选中对话框中的Telnet客户端、Telnet服务器（可能不需要，没测试），然后确定，等待 完成。这时就开启了telnet功能。 2、开始发送邮件 （发送邮件过程中不要长时间不操作命令行窗口，超过一定时间不操作的话服务器主机会主动断开连接，命令行窗口提示“遗失对主机的连接”） 1）打开命令行窗口，连接邮件服务器 在命令刚窗口输入 telnet smtp.qq.com 25(这里以qq为例，若是163，则是smtp.163.com,25是端口 号，一般情况下不会变) 如果连接成功，服务器会返回一串字符：220 smtp.qq.com Esmtp QQ Mail Server 2）向服务器表明身份 在命令行输入 helo qq.com如果成功，服务器返回 250 smtp.qq.com(qq.com可以用任何合法字符代替，本人用的名字拼音也通过了) 3）登录认证 在命令行窗口输入 auth login如果成功，服务器会返回一串字符，类似于：334 VXNlcm5hbWU6， （334 是不变的，后面的字母可能会变） 接着输入你的邮箱（xxxxx@qq.com）的base64编码之后的字符串然后回车 如果成功，服务器返回一串字符，类似于：334 UGFzc3dvcmQ6 （334 是不变的，后面的字母可能会变） 接着输入你的独立密码（注意是独立密码）的base64编码之后的字符串然后回车， 如果登录成功，服务器返回一串字符：235 Authentication successful，表示登录成功，如果不能成功登录，请检查账号密码是否正确。 4）编写邮件 输入 mail from:＜&#x4f60;&#33258;&#24049;&#x7684;&#37038;&#31665;&#65292;&#x5c31;&#x662f;&#x4e0a;&#x4e00;&#x6b65;&#x7684;&#x767b;&#x5f55;&#x90ae;&#31665;&#120;&#x78;&#120;&#x40;&#113;&#x71;&#x2e;&#x63;&#111;&#109;＞ 回车 （冒号和尖括号均为因为半角标点符号） 若格式不正确，服务器返回501 错误；若格式正确，服务器返回250 Ok。 输入 rcpt to:＜&#25910;&#20214;&#20154;&#x90ae;&#31665;&#65292;&#120;&#x78;&#120;&#64;&#x78;&#120;&#x78;&#46;&#x78;&#x78;&#x78; ＞回车 若格式不正确，服务器返回501错误；若格式正确，服务器返回250 Ok。 输入data 回车 服务器返回 354 End data with . 输入from:名字 回车， 显示在收件人收邮件时的 发件人 位置 输入 to:名字 回车， 显示收件人收邮件时的 收件人 位置 输入 subject:主题 回车， 邮件主题 空一行写邮件内容，写完之后换行，输入英文半角状态下的句号 . 表示邮件内容写完了（不要问我正文中如果包含英文半角状态下的句号怎么办） 服务器返回 250 Ok: queues as 表示邮件已经发送如 图： 二、vbScript 发送邮件 vbScript 是个比较老的语言，这里只是玩下，建议还是用JS啦。。。。 不用多说，创建一个.vbs文件，输入以下代码： 123456789101112131415161718192021NameSpace = &quot;http://schemas.microsoft.com/cdo/configuration/&quot;Set objEmail = CreateObject(&quot;CDO.Message&quot;)Call SendMail()Sub SendMailobjEmail.BodyPart.Charset = &quot;gb2312&quot;objEmail.From = &quot;xxx@xxx.com&quot;objEmail.To = &quot;xxx@163.com&quot;objectEmail Cc=&quot;xxx@163.com&quot;//抄送objectEmail Bcc=&quot;xxx@163.com&quot;//密送objEmail.Subject = &quot;subject&quot;objEmail.Textbody = &quot;电子邮件内容&quot;objEmail.AddAttachment &quot;D:\NewTest\test.rar&quot;//附件objEmail.Configuration.Fields.Item (&quot;http://schemas.microsoft.com/cdo/configuration/sendusing&quot;) = 2objEmail.Configuration.Fields.Item (&quot;http://schemas.microsoft.com/cdo/configuration/smtpserver&quot;) = &quot;smtp.exmail.qq.com&quot;objEmail.Configuration.Fields.Item (&quot;http://schemas.microsoft.com/cdo/configuration/sendusername&quot;) = &quot;你的用户名&quot;objEmail.Configuration.Fields.Item (&quot;http://schemas.microsoft.com/cdo/configuration/sendpassword&quot;) = &quot;密码&quot;objEmail.Configuration.Fields.Item (&quot;http://schemas.microsoft.com/cdo/configuration/smtpauthenticate&quot;) = 1objEmail.Configuration.Fields.Item (&quot;http://schemas.microsoft.com/cdo/configuration/smtpserverport&quot;) = 25objEmail.Configuration.Fields.UpdateobjEmail.SendEnd Sub 或者创建一个.bat文件，输入以下代码： 123456789101112131415161718192021222324echo set sh=WScript.CreateObject(&quot;WScript.Shell&quot;) &gt;telnet_tmp.vbsecho WScript.Sleep 300 &gt;&gt;telnet_tmp.vbsecho sh.SendKeys &quot;open smtp.exmail.qq.com 25&#123;ENTER&#125;&quot; &gt;&gt;telnet_tmp.vbsecho WScript.Sleep 100 &gt;&gt;telnet_tmp.vbsecho sh.SendKeys &quot;helo abc&#123;ENTER&#125;&quot; &gt;&gt;telnet_tmp.vbsecho WScript.Sleep 100 &gt;&gt;telnet_tmp.vbsecho sh.SendKeys &quot;auth login&#123;ENTER&#125;&quot; &gt;&gt;telnet_tmp.vbsecho WScript.Sleep 100 &gt;&gt;telnet_tmp.vbsecho sh.SendKeys &quot;Y3pob3VAc2Zjc2VydmljZS5jb20=&#123;ENTER&#125;&quot; &gt;&gt;telnet_tmp.vbsecho WScript.Sleep 100 &gt;&gt;telnet_tmp.vbsecho sh.SendKeys &quot;U2ZjMTIz&#123;ENTER&#125;&quot; &gt;&gt;telnet_tmp.vbsecho WScript.Sleep 100 &gt;&gt;telnet_tmp.vbsecho sh.SendKeys &quot;mail from:&lt;xxx@xxx.com&gt;&#123;ENTER&#125;&quot; &gt;&gt;telnet_tmp.vbsecho WScript.Sleep 100 &gt;&gt;telnet_tmp.vbsecho sh.SendKeys &quot;rcpt to:&lt;xxx@qq.com&gt;&#123;ENTER&#125;&quot; &gt;&gt;telnet_tmp.vbsecho WScript.Sleep 100 &gt;&gt;telnet_tmp.vbsecho sh.SendKeys &quot;data&#123;ENTER&#125;&quot; &gt;&gt;telnet_tmp.vbsecho WScript.Sleep 100 &gt;&gt;telnet_tmp.vbsecho sh.SendKeys &quot;邮件主题!!!!&#123;ENTER&#125;&#123;ENTER&#125;&quot; &gt;&gt;telnet_tmp.vbsecho sh.SendKeys &quot;邮件内容!!!!&#123;ENTER&#125;&quot; &gt;&gt;telnet_tmp.vbsecho sh.SendKeys &quot;.&#123;ENTER&#125;&quot; &gt;&gt;telnet_tmp.vbsstart telnetcscript //nologo telnet_tmp.vbsdel telnet_tmp.vbs 注意：以上登录telnet账号为base64转过后的（如：U2ZjMTIz） 三、Java发送邮件1）用spring 上代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package sendemail;import java.util.Date;import java.util.Properties;import javax.mail.MessagingException;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSenderImpl;public class SendEmail &#123;public static void main(String args[]) throws MessagingException &#123;// SendEmail a = new SendEmail();// a.sendMail();sendMail();&#125;private static void sendMail() throws MessagingException &#123;JavaMailSenderImpl senderImpl = new JavaMailSenderImpl();// 设定mail serversenderImpl.setHost(&quot;smtp.163.com&quot;);// 建立邮件消息SimpleMailMessage mailMessage = new SimpleMailMessage();// 设置收件人，寄件人 用数组发送多个邮件// String[] array = new String[] &#123;&quot;sun111@163.com&quot;,&quot;sun222@sohu.com&quot;&#125;;// mailMessage.setTo(array);mailMessage.setTo(&quot;xxx@qq.com&quot;);mailMessage.setFrom(&quot;xxx@163.com&quot;);mailMessage.setSubject(&quot; 测试简单文本邮件发送！ &quot;);mailMessage.setText(&quot; 测试我的简单邮件发送机制！！2222这是测试环境的代码 &quot; + new Date());mailMessage.setSentDate(new Date());senderImpl.setPort(25);senderImpl.setUsername(&quot;wuxin130&quot;); // 根据自己的情况,设置usernamesenderImpl.setPassword(&quot;sss&quot;); // 根据自己的情况, 设置passwordsenderImpl.setDefaultEncoding(&quot;UTF-8&quot;);Properties prop = new Properties();// prop.put(&quot;mail.smtp.auth&quot;, &quot;true&quot;); //// 将这个参数设为true，让服务器进行认证,认证用户名和密码是否正确prop.put(&quot;mail.smtp.timeout&quot;, &quot;25000&quot;);prop.put(&quot;mail.debug&quot;, &quot;true&quot;);// 便于调试prop.put(&quot;mail.transport.protocol&quot;, &quot;smtp&quot;);/*** 关键代码， 出现554 DT:SPM 163 smtp5,D9GowACHO7RNWNdXmXs1Bw--.9035S2* 1473730639, please see* http://mail.163.com/help/help_spam_16.htm?ip=124.251.36.10* &amp;hostid=smtp5&amp;time=1473730639 原因是：ip与域名不匹配。*/prop.put(&quot;mail.smtp.localhost&quot;, &quot;mail.digu.com&quot;);prop.put(&quot;mail.smtp.auth&quot;, &quot;false&quot;);prop.put(&quot;mail.smtp.port&quot;, &quot;25&quot;);senderImpl.setJavaMailProperties(prop);// 发送邮件senderImpl.send(mailMessage);System.out.println(&quot; 邮件发送成功.. &quot;);&#125;&#125; 注意: 一定要导入org.springframework.beans-3.0.5.RELEASE.jarorg.springframework.core-3.0.5.RELEASE.jar mail.jarspring-context-support-4.3.4.RELEASE.jar四个jar包 2）基于JavaMail的Java邮件发送：复杂邮件发送 一封复杂的邮件内容可以看做是由很多节点（或者可以说是“片段”/“部分”/“零件”）组成，文本、图片、附件等都可以看成是邮件内容中的一个节点。这些节点之间又可以相互关联组合成一个节点。最终组合成一个大节点就是邮件的正文内容。需要两个jar包：activation.jarmail.jar 这个jar包一定用最新的，我用的1.4.7 成功了 完整代码演示:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135package com.xiets.javamaildemo;import java.io.FileOutputStream;import java.util.Date;import java.util.Properties;import javax.activation.DataHandler;import javax.activation.FileDataSource;import javax.mail.Message.RecipientType;import javax.mail.Session;import javax.mail.Transport;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeBodyPart;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeMultipart;import javax.mail.internet.MimeUtility;/** * 创建并发送一封包含文本、图片、附件的复杂邮件 * * @author xietansheng */public class Main &#123; // 发件人的 邮箱 和 密码（替换为自己的邮箱和密码） public static String myEmailAccount = &quot;xxxxxxxx@163.com&quot;; public static String myEmailPassword = &quot;xxxxxxxx&quot;; // 发件人邮箱的 SMTP 服务器地址, 必须准确, 不同邮件服务器地址不同, 一般格式为: smtp.xxx.com // 网易163邮箱的 SMTP 服务器地址为: smtp.163.com public static String myEmailSMTPHost = &quot;smtp.163.com&quot;; // 收件人邮箱（替换为自己知道的有效邮箱） public static String receiveMailAccount = &quot;xiejava@qq.com&quot;; public static void main(String[] args) throws Exception &#123; // 1. 创建参数配置, 用于连接邮件服务器的参数配置 Properties props = new Properties(); // 参数配置 props.setProperty(&quot;mail.transport.protocol&quot;, &quot;smtp&quot;); // 使用的协议（JavaMail规范要求） props.setProperty(&quot;mail.smtp.host&quot;, myEmailSMTPHost); // 发件人的邮箱的 SMTP 服务器地址 props.setProperty(&quot;mail.smtp.auth&quot;, &quot;true&quot;); // 需要请求认证 // 开启 SSL 连接, 以及更详细的发送步骤请看上一篇: 基于 JavaMail 的 Java 邮件发送：简单邮件发送 // 2. 根据配置创建会话对象, 用于和邮件服务器交互 Session session = Session.getDefaultInstance(props); session.setDebug(true); // 设置为debug模式, 可以查看详细的发送 log // 3. 创建一封邮件 MimeMessage message = createMimeMessage(session, myEmailAccount, receiveMailAccount); // 也可以保持到本地查看 // message.writeTo(file_out_put_stream); // 4. 根据 Session 获取邮件传输对象 Transport transport = session.getTransport(); // 5. 使用 邮箱账号 和 密码 连接邮件服务器 // 这里认证的邮箱必须与 message 中的发件人邮箱一致，否则报错 transport.connect(myEmailAccount, myEmailPassword); // 6. 发送邮件, 发到所有的收件地址, message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, 抄送人, 密送人 transport.sendMessage(message, message.getAllRecipients()); // 7. 关闭连接 transport.close(); &#125; /** * 创建一封复杂邮件（文本+图片+附件） */ public static MimeMessage createMimeMessage(Session session, String sendMail, String receiveMail) throws Exception &#123; // 1. 创建邮件对象 MimeMessage message = new MimeMessage(session); // 2. From: 发件人 message.setFrom(new InternetAddress(sendMail, &quot;我的测试邮件_发件人昵称&quot;, &quot;UTF-8&quot;)); // 3. To: 收件人（可以增加多个收件人、抄送、密送） message.addRecipient(RecipientType.TO, new InternetAddress(receiveMail, &quot;我的测试邮件_收件人昵称&quot;, &quot;UTF-8&quot;)); // 4. Subject: 邮件主题 message.setSubject(&quot;TEST邮件主题（文本+图片+附件）&quot;, &quot;UTF-8&quot;); /* * 下面是邮件内容的创建: */ // 5. 创建图片“节点” MimeBodyPart image = new MimeBodyPart(); DataHandler dh = new DataHandler(new FileDataSource(&quot;FairyTail.jpg&quot;)); // 读取本地文件 image.setDataHandler(dh); // 将图片数据添加到“节点” image.setContentID(&quot;image_fairy_tail&quot;); // 为“节点”设置一个唯一编号（在文本“节点”将引用该ID） // 6. 创建文本“节点” MimeBodyPart text = new MimeBodyPart(); // 这里添加图片的方式是将整个图片包含到邮件内容中, 实际上也可以以 http 链接的形式添加网络图片 text.setContent(&quot;这是一张图片&lt;br/&gt;&lt;img src=&apos;cid:image_fairy_tail&apos;/&gt;&quot;, &quot;text/html;charset=UTF-8&quot;); // 7. （文本+图片）设置 文本 和 图片 “节点”的关系（将 文本 和 图片 “节点”合成一个混合“节点”） MimeMultipart mm_text_image = new MimeMultipart(); mm_text_image.addBodyPart(text); mm_text_image.addBodyPart(image); mm_text_image.setSubType(&quot;related&quot;); // 关联关系 // 8. 将 文本+图片 的混合“节点”封装成一个普通“节点” // 最终添加到邮件的 Content 是由多个 BodyPart 组成的 Multipart, 所以我们需要的是 BodyPart, // 上面的 mm_text_image 并非 BodyPart, 所有要把 mm_text_image 封装成一个 BodyPart MimeBodyPart text_image = new MimeBodyPart(); text_image.setContent(mm_text_image); // 9. 创建附件“节点” MimeBodyPart attachment = new MimeBodyPart(); DataHandler dh2 = new DataHandler(new FileDataSource(&quot;妖精的尾巴目录.doc&quot;)); // 读取本地文件 attachment.setDataHandler(dh2); // 将附件数据添加到“节点” attachment.setFileName(MimeUtility.encodeText(dh2.getName())); // 设置附件的文件名（需要编码） // 10. 设置（文本+图片）和 附件 的关系（合成一个大的混合“节点” / Multipart ） MimeMultipart mm = new MimeMultipart(); mm.addBodyPart(text_image); mm.addBodyPart(attachment); // 如果有多个附件，可以创建多个多次添加 mm.setSubType(&quot;mixed&quot;); // 混合关系 // 11. 设置整个邮件的关系（将最终的混合“节点”作为邮件的内容添加到邮件对象） message.setContent(mm); // 12. 设置发件时间 message.setSentDate(new Date()); // 13. 保存上面的所有设置 message.saveChanges(); return message; &#125;&#125; 如果只是想发送文本和附件，参考一下代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.sendemail;import java.util.Date;import java.util.Properties;import javax.activation.DataHandler;import javax.activation.FileDataSource;import javax.mail.Session;import javax.mail.Transport;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeBodyPart;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeMessage.RecipientType;import javax.mail.internet.MimeMultipart;import javax.mail.internet.MimeUtility;public class SendEmail2 &#123; // 发件人的 邮箱 和 密码（替换为自己的邮箱和密码） public static String myEmailAccount = &quot;xxx@xxx.com&quot;; public static String myEmailPassword = &quot;*********&quot;; // 发件人邮箱的 SMTP 服务器地址, 必须准确, 不同邮件服务器地址不同, 一般格式为: smtp.xxx.com // 网易163邮箱的 SMTP 服务器地址为: smtp.163.com public static String myEmailSMTPHost = &quot;smtp.exmail.qq.com&quot;; // 收件人邮箱（替换为自己知道的有效邮箱） public static String receiveMailAccount = &quot;xxx@qq.com&quot;; // 收件人邮箱（替换为自己知道的有效邮箱） public static String receiveMailCcAccount = &quot;13026162269@163.com&quot;; public static void main(String[] args) throws Exception &#123; // 1. 创建参数配置, 用于连接邮件服务器的参数配置 Properties props = new Properties(); // 参数配置 props.setProperty(&quot;mail.transport.protocol&quot;, &quot;smtp&quot;); // 使用的协议（JavaMail规范要求） props.setProperty(&quot;mail.smtp.host&quot;, myEmailSMTPHost); // 发件人的邮箱的 SMTP // 服务器地址 props.setProperty(&quot;mail.smtp.auth&quot;, &quot;true&quot;); // 需要请求认证 // 开启 SSL 连接, 以及更详细的发送步骤请看上一篇: 基于 JavaMail 的 Java 邮件发送：简单邮件发送 // 2. 根据配置创建会话对象, 用于和邮件服务器交互 Session session = Session.getDefaultInstance(props); session.setDebug(true); // 设置为debug模式, 可以查看详细的发送 log // 3. 创建一封邮件 MimeMessage message = createMimeMessage(session, myEmailAccount, receiveMailAccount, receiveMailCcAccount); // 也可以保持到本地查看 // message.writeTo(file_out_put_stream); // 4. 根据 Session 获取邮件传输对象 Transport transport = session.getTransport(); // 5. 使用 邮箱账号 和 密码 连接邮件服务器 // 这里认证的邮箱必须与 message 中的发件人邮箱一致，否则报错 transport.connect(myEmailAccount, myEmailPassword); // 6. 发送邮件, 发到所有的收件地址, message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, // 抄送人, 密送人 transport.sendMessage(message, message.getAllRecipients()); // 7. 关闭连接 transport.close(); &#125; /** * 创建一封复杂邮件（文本+图片+附件） */ public static MimeMessage createMimeMessage(Session session, String sendMail, String receiveMail, String receiveMailCc) throws Exception &#123; // 1. 创建邮件对象 MimeMessage message = new MimeMessage(session); // 2. From: 发件人 message.setFrom(new InternetAddress(sendMail, &quot;t-mac&quot;, &quot;UTF-8&quot;)); // 3. To: 收件人（可以增加多个收件人、抄送、密送） message.addRecipient(RecipientType.TO, new InternetAddress(receiveMail, &quot;yao&quot;, &quot;UTF-8&quot;)); message.addRecipient(RecipientType.CC, new InternetAddress( receiveMailCc, &quot;yaoming&quot;, &quot;UTF-8&quot;)); // 4. Subject: 邮件主题 message.setSubject(&quot;TEST邮件主题（文本+图片+附件）&quot;, &quot;UTF-8&quot;); // 添加文本 MimeBodyPart htmlPart = new MimeBodyPart(); htmlPart.setContent( &quot;hahahahh&quot;,&quot;text/html;charset=UTF-8&quot;); /* * 下面是邮件内容的创建: */ // 9. 创建附件“节点” MimeBodyPart attachment = new MimeBodyPart(); DataHandler dh2 = new DataHandler(new FileDataSource( &quot;E:\\test\\NewTest\\Download.CSV&quot;)); // 读取本地文件 attachment.setDataHandler(dh2); // 将附件数据添加到“节点” attachment.setFileName(MimeUtility.encodeText(dh2.getName())); // 设置附件的文件名（需要编码） // 10. 设置（文本+图片）和 附件 的关系（合成一个大的混合“节点” / Multipart ） MimeMultipart mm = new MimeMultipart(); mm.addBodyPart(htmlPart); mm.addBodyPart(attachment); // 如果有多个附件，可以创建多个多次添加 mm.setSubType(&quot;mixed&quot;); // 混合关系 // 11. 设置整个邮件的关系（将最终的混合“节点”作为邮件的内容添加到邮件对象） message.setContent(mm); // 12. 设置发件时间 message.setSentDate(new Date()); // message.setText(&quot;保存上面的所有设置&quot;);// 设置文本内容 // 13. 保存上面的所有设置 message.saveChanges(); return message; &#125;&#125; 四、Python发送邮件 终于来到了Python，不多说，直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164# -*- coding: utf-8 -*-&apos;&apos;&apos;发送邮件&apos;&apos;&apos;import smtplibfrom email.mime.base import MIMEBasefrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextimport os.pathimport emailimport mimetypesimport osfrom os.path import join, getsizeimport tracebackclass EmailManager: &apos;&apos;&apos; send email to the given email address automatically &apos;&apos;&apos; def __init__(self, **kw): &apos; 构造函数 &apos; self.kw = kw # self.smtp_server = &quot;smtp.exmail.qq.com&quot; self.MAX_FILE_SIZE = 10 * 1024 * 1024 # 10M def run(self): # 总入口 try: # 初始化 self.__my_init() # 登录SMTP服务器，验证授权 server = self.get_login_server() # 生成邮件主体内容 main_msg = self.get_main_msg() # 生成邮件附件内容 file_msg = self.get_attach_file_msg() if file_msg is not None: main_msg.attach(file_msg) # 得到格式化后的完整文本 fullText = main_msg.as_string() # 发送邮件 server.sendmail(self.msg_from, self.receiver, fullText) except Exception as e: print(e) exstr = traceback.format_exc() print(exstr) server.quit() exit() def get_main_msg(self): &apos; 生成邮件主体内容 &apos; # 构造MIMEMultipart对象做为根容器 main_msg = MIMEMultipart() # 构造MIMEText对象做为邮件显示内容并附加到根容器 text_msg = MIMEText(self.msg_content, _charset=&quot;utf-8&quot;) main_msg.attach(text_msg) # 设置根容器属性 main_msg[&apos;From&apos;] = self.msg_from main_msg[&apos;To&apos;] = self.msg_to main_msg[&apos;Cc&apos;] = self.msg_cc main_msg[&apos;Subject&apos;] = self.msg_subject main_msg[&apos;Date&apos;] = self.msg_date return main_msg def get_attach_file_msg(self): &apos; 生成邮件附件内容 &apos; if self.attach_file is not None and self.attach_file != &quot;&quot;: try: self.validate_file_size() data = open(self.attach_file, &apos;rb&apos;) ctype, encoding = mimetypes.guess_type(self.attach_file) if ctype is None or encoding is not None: ctype = &apos;application/octet-stream&apos; maintype, subtype = ctype.split(&apos;/&apos;, 1) file_msg = MIMEBase(maintype, subtype) file_msg.set_payload(data.read()) data.close() email.encoders.encode_base64(file_msg) # 把附件编码 ## 设置附件头 basename = os.path.basename(self.attach_file) file_msg.add_header(&apos;Content-Disposition&apos;, &apos;attachment&apos;, filename=basename) # 修改邮件头 return file_msg except Exception as e: print(e) return None else: return None def get_login_server(self): &apos; 登录SMTP服务器，验证授权信息 &apos; server = smtplib.SMTP(self.smtp_server) server.login(self.server_username, self.server_pwd) # 仅smtp服务器需要验证时 return server def validate_file_size(self): &apos; 验证文件大小是否合法 &apos; if getsize(self.attach_file) &gt; self.MAX_FILE_SIZE: raise Exception(u&apos;附件过大，上传失败&apos;) def __my_init(self): &apos; 配置初始化 &apos; # 邮箱登录设置 self.smtp_server = self.__get_cfg(&apos;smtp_server&apos;) self.server_username = self.__get_cfg(&apos;server_username&apos;) self.server_pwd = self.__get_cfg(&apos;server_pwd&apos;) # 邮件内容设置 self.receiver = self.__get_cfg(&apos;msg_to&apos;) + self.__get_cfg(&apos;msg_cc&apos;) self.msg_from = self.server_username self.msg_to = &apos;,&apos;.join(self.__get_cfg(&apos;msg_to&apos;)) self.msg_cc = &apos;,&apos;.join(self.__get_cfg(&apos;msg_cc&apos;)) self.msg_subject = self.__get_cfg(&apos;msg_subject&apos;) self.msg_date = self.__get_cfg(&apos;msg_date&apos;) print(self.msg_date) self.msg_content = self.__get_cfg(&apos;msg_content&apos;) # 附件 self.attach_file = self.__get_cfg(&apos;attach_file&apos;, throw=False) def __get_cfg(self, key, throw=True): &apos; 根据key从**kw中取得相应的配置内容 &apos; cfg = self.kw.get(key) if throw == True and (cfg is None or cfg == &apos;&apos;): raise Exception(&quot;配置不能为空！&quot;.decode(&apos;utf-8&apos;)) return cfg以下为调用代码：mail_cfg = &#123; # 邮箱登录设置，使用SMTP登录 &apos;server_username&apos;: &apos;czhou@sfcservice.com&apos;, &apos;server_pwd&apos;: &apos;密码&apos;, &apos;smtp_server&apos;: &apos;smtp.exmail.qq.com&apos;, # 邮件内容设置 &apos;msg_to&apos;: [&apos;czhou@sfcservice.com&apos;], # 可以在此添加收件人,一定要list类型 &apos;msg_cc&apos;: [&apos;zone_c@qq.com&apos;, &apos;13026162269@163.com&apos;], &apos;msg_subject&apos;: u&apos;代码&apos;, &apos;msg_date&apos;: time.strftime(&apos;%Y-%m-%d %X&apos;, time.localtime()), &apos;msg_content&apos;: u&quot;我的备份&quot;, # 附件 &apos;attach_file&apos;: &apos;E:\\test\\NewTest\\test.txt&apos;&#125;# print( time.strftime(&apos;%Y-%m-%d %X&apos;, time.localtime()))email_manager = EmailManager(**mail_cfg)email_manager.run()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[测试文章]]></title>
      <url>%2F2016%2F09%2F03%2Fhexo-test%2F</url>
      <content type="text"><![CDATA[biaotibaagaagar]]></content>
    </entry>

    
  
  
</search>
