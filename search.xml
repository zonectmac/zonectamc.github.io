<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[实现发送邮箱的几种方法]]></title>
      <url>%2F2017%2F04%2F22%2Fsend-email%2F</url>
      <content type="text"><![CDATA[以下为众多方法中的几种，后面继续补充。。。。。 一、telnet windows下使用cmd（命令行）发送邮件 1、windows开启telnet服务 打开控制面板，找到“打开或关闭windows功能”（在“程序”里面），选中对话框中的Telnet客户端、Telnet服务器（可能不需要，没测试），然后确定，等待 完成。这时就开启了telnet功能。 2、开始发送邮件 （发送邮件过程中不要长时间不操作命令行窗口，超过一定时间不操作的话服务器主机会主动断开连接，命令行窗口提示“遗失对主机的连接”） 1）打开命令行窗口，连接邮件服务器 在命令刚窗口输入 telnet smtp.qq.com 25(这里以qq为例，若是163，则是smtp.163.com,25是端口 号，一般情况下不会变) 如果连接成功，服务器会返回一串字符：220 smtp.qq.com Esmtp QQ Mail Server 2）向服务器表明身份 在命令行输入 helo qq.com如果成功，服务器返回 250 smtp.qq.com(qq.com可以用任何合法字符代替，本人用的名字拼音也通过了) 3）登录认证 在命令行窗口输入 auth login如果成功，服务器会返回一串字符，类似于：334 VXNlcm5hbWU6， （334 是不变的，后面的字母可能会变） 接着输入你的邮箱（xxxxx@qq.com）的base64编码之后的字符串然后回车 如果成功，服务器返回一串字符，类似于：334 UGFzc3dvcmQ6 （334 是不变的，后面的字母可能会变） 接着输入你的独立密码（注意是独立密码）的base64编码之后的字符串然后回车， 如果登录成功，服务器返回一串字符：235 Authentication successful，表示登录成功，如果不能成功登录，请检查账号密码是否正确。 4）编写邮件 输入 mail from:＜&#20320;&#x81ea;&#x5df1;&#x7684;&#37038;&#31665;&#65292;&#x5c31;&#26159;&#19978;&#19968;&#x6b65;&#x7684;&#x767b;&#x5f55;&#x90ae;&#x7bb1;&#120;&#x78;&#x78;&#64;&#x71;&#113;&#x2e;&#99;&#x6f;&#x6d;＞ 回车 （冒号和尖括号均为因为半角标点符号） 若格式不正确，服务器返回501 错误；若格式正确，服务器返回250 Ok。 输入 rcpt to:＜&#25910;&#x4ef6;&#20154;&#x90ae;&#x7bb1;&#65292;&#120;&#120;&#x78;&#x40;&#x78;&#120;&#120;&#46;&#120;&#120;&#x78; ＞回车 若格式不正确，服务器返回501错误；若格式正确，服务器返回250 Ok。 输入data 回车 服务器返回 354 End data with . 输入from:名字 回车， 显示在收件人收邮件时的 发件人 位置 输入 to:名字 回车， 显示收件人收邮件时的 收件人 位置 输入 subject:主题 回车， 邮件主题 空一行写邮件内容，写完之后换行，输入英文半角状态下的句号 . 表示邮件内容写完了（不要问我正文中如果包含英文半角状态下的句号怎么办） 服务器返回 250 Ok: queues as 表示邮件已经发送如 图： 二、vbScript 发送邮件 vbScript 是个比较老的语言，这里只是玩下，建议还是用JS啦。。。。 不用多说，创建一个.vbs文件，输入以下代码： 123456789101112131415161718192021NameSpace = &quot;http://schemas.microsoft.com/cdo/configuration/&quot;Set objEmail = CreateObject(&quot;CDO.Message&quot;)Call SendMail()Sub SendMailobjEmail.BodyPart.Charset = &quot;gb2312&quot;objEmail.From = &quot;xxx@xxx.com&quot;objEmail.To = &quot;xxx@163.com&quot;objectEmail Cc=&quot;xxx@163.com&quot;//抄送objectEmail Bcc=&quot;xxx@163.com&quot;//密送objEmail.Subject = &quot;subject&quot;objEmail.Textbody = &quot;电子邮件内容&quot;objEmail.AddAttachment &quot;D:\NewTest\test.rar&quot;//附件objEmail.Configuration.Fields.Item (&quot;http://schemas.microsoft.com/cdo/configuration/sendusing&quot;) = 2objEmail.Configuration.Fields.Item (&quot;http://schemas.microsoft.com/cdo/configuration/smtpserver&quot;) = &quot;smtp.exmail.qq.com&quot;objEmail.Configuration.Fields.Item (&quot;http://schemas.microsoft.com/cdo/configuration/sendusername&quot;) = &quot;你的用户名&quot;objEmail.Configuration.Fields.Item (&quot;http://schemas.microsoft.com/cdo/configuration/sendpassword&quot;) = &quot;密码&quot;objEmail.Configuration.Fields.Item (&quot;http://schemas.microsoft.com/cdo/configuration/smtpauthenticate&quot;) = 1objEmail.Configuration.Fields.Item (&quot;http://schemas.microsoft.com/cdo/configuration/smtpserverport&quot;) = 25objEmail.Configuration.Fields.UpdateobjEmail.SendEnd Sub 或者创建一个.bat文件，输入以下代码： 123456789101112131415161718192021222324echo set sh=WScript.CreateObject(&quot;WScript.Shell&quot;) &gt;telnet_tmp.vbsecho WScript.Sleep 300 &gt;&gt;telnet_tmp.vbsecho sh.SendKeys &quot;open smtp.exmail.qq.com 25&#123;ENTER&#125;&quot; &gt;&gt;telnet_tmp.vbsecho WScript.Sleep 100 &gt;&gt;telnet_tmp.vbsecho sh.SendKeys &quot;helo abc&#123;ENTER&#125;&quot; &gt;&gt;telnet_tmp.vbsecho WScript.Sleep 100 &gt;&gt;telnet_tmp.vbsecho sh.SendKeys &quot;auth login&#123;ENTER&#125;&quot; &gt;&gt;telnet_tmp.vbsecho WScript.Sleep 100 &gt;&gt;telnet_tmp.vbsecho sh.SendKeys &quot;Y3pob3VAc2Zjc2VydmljZS5jb20=&#123;ENTER&#125;&quot; &gt;&gt;telnet_tmp.vbsecho WScript.Sleep 100 &gt;&gt;telnet_tmp.vbsecho sh.SendKeys &quot;U2ZjMTIz&#123;ENTER&#125;&quot; &gt;&gt;telnet_tmp.vbsecho WScript.Sleep 100 &gt;&gt;telnet_tmp.vbsecho sh.SendKeys &quot;mail from:&lt;xxx@xxx.com&gt;&#123;ENTER&#125;&quot; &gt;&gt;telnet_tmp.vbsecho WScript.Sleep 100 &gt;&gt;telnet_tmp.vbsecho sh.SendKeys &quot;rcpt to:&lt;xxx@qq.com&gt;&#123;ENTER&#125;&quot; &gt;&gt;telnet_tmp.vbsecho WScript.Sleep 100 &gt;&gt;telnet_tmp.vbsecho sh.SendKeys &quot;data&#123;ENTER&#125;&quot; &gt;&gt;telnet_tmp.vbsecho WScript.Sleep 100 &gt;&gt;telnet_tmp.vbsecho sh.SendKeys &quot;邮件主题!!!!&#123;ENTER&#125;&#123;ENTER&#125;&quot; &gt;&gt;telnet_tmp.vbsecho sh.SendKeys &quot;邮件内容!!!!&#123;ENTER&#125;&quot; &gt;&gt;telnet_tmp.vbsecho sh.SendKeys &quot;.&#123;ENTER&#125;&quot; &gt;&gt;telnet_tmp.vbsstart telnetcscript //nologo telnet_tmp.vbsdel telnet_tmp.vbs 注意：以上登录telnet账号为base64转过后的（如：U2ZjMTIz） 三、Java发送邮件 1）用spring 上代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package sendemail;import java.util.Date;import java.util.Properties;import javax.mail.MessagingException;import org.springframework.mail.SimpleMailMessage;import org.springframework.mail.javamail.JavaMailSenderImpl;public class SendEmail &#123;public static void main(String args[]) throws MessagingException &#123;// SendEmail a = new SendEmail();// a.sendMail();sendMail();&#125;private static void sendMail() throws MessagingException &#123;JavaMailSenderImpl senderImpl = new JavaMailSenderImpl();// 设定mail serversenderImpl.setHost(&quot;smtp.163.com&quot;);// 建立邮件消息SimpleMailMessage mailMessage = new SimpleMailMessage();// 设置收件人，寄件人 用数组发送多个邮件// String[] array = new String[] &#123;&quot;sun111@163.com&quot;,&quot;sun222@sohu.com&quot;&#125;;// mailMessage.setTo(array);mailMessage.setTo(&quot;xxx@qq.com&quot;);mailMessage.setFrom(&quot;xxx@163.com&quot;);mailMessage.setSubject(&quot; 测试简单文本邮件发送！ &quot;);mailMessage.setText(&quot; 测试我的简单邮件发送机制！！2222这是测试环境的代码 &quot; + new Date());mailMessage.setSentDate(new Date());senderImpl.setPort(25);senderImpl.setUsername(&quot;wuxin130&quot;); // 根据自己的情况,设置usernamesenderImpl.setPassword(&quot;sss&quot;); // 根据自己的情况, 设置passwordsenderImpl.setDefaultEncoding(&quot;UTF-8&quot;);Properties prop = new Properties();// prop.put(&quot;mail.smtp.auth&quot;, &quot;true&quot;); //// 将这个参数设为true，让服务器进行认证,认证用户名和密码是否正确prop.put(&quot;mail.smtp.timeout&quot;, &quot;25000&quot;);prop.put(&quot;mail.debug&quot;, &quot;true&quot;);// 便于调试prop.put(&quot;mail.transport.protocol&quot;, &quot;smtp&quot;);/*** 关键代码， 出现554 DT:SPM 163 smtp5,D9GowACHO7RNWNdXmXs1Bw--.9035S2* 1473730639, please see* http://mail.163.com/help/help_spam_16.htm?ip=124.251.36.10* &amp;hostid=smtp5&amp;time=1473730639 原因是：ip与域名不匹配。*/prop.put(&quot;mail.smtp.localhost&quot;, &quot;mail.digu.com&quot;);prop.put(&quot;mail.smtp.auth&quot;, &quot;false&quot;);prop.put(&quot;mail.smtp.port&quot;, &quot;25&quot;);senderImpl.setJavaMailProperties(prop);// 发送邮件senderImpl.send(mailMessage);System.out.println(&quot; 邮件发送成功.. &quot;);&#125;&#125; 注意: 一定要导入org.springframework.beans-3.0.5.RELEASE.jarorg.springframework.core-3.0.5.RELEASE.jar mail.jarspring-context-support-4.3.4.RELEASE.jar四个jar包 2）基于JavaMail的Java邮件发送：复杂邮件发送 一封复杂的邮件内容可以看做是由很多节点（或者可以说是“片段”/“部分”/“零件”）组成，文本、图片、附件等都可以看成是邮件内容中的一个节点。这些节点之间又可以相互关联组合成一个节点。最终组合成一个大节点就是邮件的正文内容。需要两个jar包：activation.jarmail.jar 这个jar包一定用最新的，我用的1.4.7 成功了 完整代码演示:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135package com.xiets.javamaildemo;import java.io.FileOutputStream;import java.util.Date;import java.util.Properties;import javax.activation.DataHandler;import javax.activation.FileDataSource;import javax.mail.Message.RecipientType;import javax.mail.Session;import javax.mail.Transport;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeBodyPart;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeMultipart;import javax.mail.internet.MimeUtility;/** * 创建并发送一封包含文本、图片、附件的复杂邮件 * * @author xietansheng */public class Main &#123; // 发件人的 邮箱 和 密码（替换为自己的邮箱和密码） public static String myEmailAccount = &quot;xxxxxxxx@163.com&quot;; public static String myEmailPassword = &quot;xxxxxxxx&quot;; // 发件人邮箱的 SMTP 服务器地址, 必须准确, 不同邮件服务器地址不同, 一般格式为: smtp.xxx.com // 网易163邮箱的 SMTP 服务器地址为: smtp.163.com public static String myEmailSMTPHost = &quot;smtp.163.com&quot;; // 收件人邮箱（替换为自己知道的有效邮箱） public static String receiveMailAccount = &quot;xiejava@qq.com&quot;; public static void main(String[] args) throws Exception &#123; // 1. 创建参数配置, 用于连接邮件服务器的参数配置 Properties props = new Properties(); // 参数配置 props.setProperty(&quot;mail.transport.protocol&quot;, &quot;smtp&quot;); // 使用的协议（JavaMail规范要求） props.setProperty(&quot;mail.smtp.host&quot;, myEmailSMTPHost); // 发件人的邮箱的 SMTP 服务器地址 props.setProperty(&quot;mail.smtp.auth&quot;, &quot;true&quot;); // 需要请求认证 // 开启 SSL 连接, 以及更详细的发送步骤请看上一篇: 基于 JavaMail 的 Java 邮件发送：简单邮件发送 // 2. 根据配置创建会话对象, 用于和邮件服务器交互 Session session = Session.getDefaultInstance(props); session.setDebug(true); // 设置为debug模式, 可以查看详细的发送 log // 3. 创建一封邮件 MimeMessage message = createMimeMessage(session, myEmailAccount, receiveMailAccount); // 也可以保持到本地查看 // message.writeTo(file_out_put_stream); // 4. 根据 Session 获取邮件传输对象 Transport transport = session.getTransport(); // 5. 使用 邮箱账号 和 密码 连接邮件服务器 // 这里认证的邮箱必须与 message 中的发件人邮箱一致，否则报错 transport.connect(myEmailAccount, myEmailPassword); // 6. 发送邮件, 发到所有的收件地址, message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, 抄送人, 密送人 transport.sendMessage(message, message.getAllRecipients()); // 7. 关闭连接 transport.close(); &#125; /** * 创建一封复杂邮件（文本+图片+附件） */ public static MimeMessage createMimeMessage(Session session, String sendMail, String receiveMail) throws Exception &#123; // 1. 创建邮件对象 MimeMessage message = new MimeMessage(session); // 2. From: 发件人 message.setFrom(new InternetAddress(sendMail, &quot;我的测试邮件_发件人昵称&quot;, &quot;UTF-8&quot;)); // 3. To: 收件人（可以增加多个收件人、抄送、密送） message.addRecipient(RecipientType.TO, new InternetAddress(receiveMail, &quot;我的测试邮件_收件人昵称&quot;, &quot;UTF-8&quot;)); // 4. Subject: 邮件主题 message.setSubject(&quot;TEST邮件主题（文本+图片+附件）&quot;, &quot;UTF-8&quot;); /* * 下面是邮件内容的创建: */ // 5. 创建图片“节点” MimeBodyPart image = new MimeBodyPart(); DataHandler dh = new DataHandler(new FileDataSource(&quot;FairyTail.jpg&quot;)); // 读取本地文件 image.setDataHandler(dh); // 将图片数据添加到“节点” image.setContentID(&quot;image_fairy_tail&quot;); // 为“节点”设置一个唯一编号（在文本“节点”将引用该ID） // 6. 创建文本“节点” MimeBodyPart text = new MimeBodyPart(); // 这里添加图片的方式是将整个图片包含到邮件内容中, 实际上也可以以 http 链接的形式添加网络图片 text.setContent(&quot;这是一张图片&lt;br/&gt;&lt;img src=&apos;cid:image_fairy_tail&apos;/&gt;&quot;, &quot;text/html;charset=UTF-8&quot;); // 7. （文本+图片）设置 文本 和 图片 “节点”的关系（将 文本 和 图片 “节点”合成一个混合“节点”） MimeMultipart mm_text_image = new MimeMultipart(); mm_text_image.addBodyPart(text); mm_text_image.addBodyPart(image); mm_text_image.setSubType(&quot;related&quot;); // 关联关系 // 8. 将 文本+图片 的混合“节点”封装成一个普通“节点” // 最终添加到邮件的 Content 是由多个 BodyPart 组成的 Multipart, 所以我们需要的是 BodyPart, // 上面的 mm_text_image 并非 BodyPart, 所有要把 mm_text_image 封装成一个 BodyPart MimeBodyPart text_image = new MimeBodyPart(); text_image.setContent(mm_text_image); // 9. 创建附件“节点” MimeBodyPart attachment = new MimeBodyPart(); DataHandler dh2 = new DataHandler(new FileDataSource(&quot;妖精的尾巴目录.doc&quot;)); // 读取本地文件 attachment.setDataHandler(dh2); // 将附件数据添加到“节点” attachment.setFileName(MimeUtility.encodeText(dh2.getName())); // 设置附件的文件名（需要编码） // 10. 设置（文本+图片）和 附件 的关系（合成一个大的混合“节点” / Multipart ） MimeMultipart mm = new MimeMultipart(); mm.addBodyPart(text_image); mm.addBodyPart(attachment); // 如果有多个附件，可以创建多个多次添加 mm.setSubType(&quot;mixed&quot;); // 混合关系 // 11. 设置整个邮件的关系（将最终的混合“节点”作为邮件的内容添加到邮件对象） message.setContent(mm); // 12. 设置发件时间 message.setSentDate(new Date()); // 13. 保存上面的所有设置 message.saveChanges(); return message; &#125;&#125; 如果只是想发送文本和附件，参考一下代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.sendemail;import java.util.Date;import java.util.Properties;import javax.activation.DataHandler;import javax.activation.FileDataSource;import javax.mail.Session;import javax.mail.Transport;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeBodyPart;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeMessage.RecipientType;import javax.mail.internet.MimeMultipart;import javax.mail.internet.MimeUtility;public class SendEmail2 &#123; // 发件人的 邮箱 和 密码（替换为自己的邮箱和密码） public static String myEmailAccount = &quot;xxx@xxx.com&quot;; public static String myEmailPassword = &quot;*********&quot;; // 发件人邮箱的 SMTP 服务器地址, 必须准确, 不同邮件服务器地址不同, 一般格式为: smtp.xxx.com // 网易163邮箱的 SMTP 服务器地址为: smtp.163.com public static String myEmailSMTPHost = &quot;smtp.exmail.qq.com&quot;; // 收件人邮箱（替换为自己知道的有效邮箱） public static String receiveMailAccount = &quot;xxx@qq.com&quot;; // 收件人邮箱（替换为自己知道的有效邮箱） public static String receiveMailCcAccount = &quot;13026162269@163.com&quot;; public static void main(String[] args) throws Exception &#123; // 1. 创建参数配置, 用于连接邮件服务器的参数配置 Properties props = new Properties(); // 参数配置 props.setProperty(&quot;mail.transport.protocol&quot;, &quot;smtp&quot;); // 使用的协议（JavaMail规范要求） props.setProperty(&quot;mail.smtp.host&quot;, myEmailSMTPHost); // 发件人的邮箱的 SMTP // 服务器地址 props.setProperty(&quot;mail.smtp.auth&quot;, &quot;true&quot;); // 需要请求认证 // 开启 SSL 连接, 以及更详细的发送步骤请看上一篇: 基于 JavaMail 的 Java 邮件发送：简单邮件发送 // 2. 根据配置创建会话对象, 用于和邮件服务器交互 Session session = Session.getDefaultInstance(props); session.setDebug(true); // 设置为debug模式, 可以查看详细的发送 log // 3. 创建一封邮件 MimeMessage message = createMimeMessage(session, myEmailAccount, receiveMailAccount, receiveMailCcAccount); // 也可以保持到本地查看 // message.writeTo(file_out_put_stream); // 4. 根据 Session 获取邮件传输对象 Transport transport = session.getTransport(); // 5. 使用 邮箱账号 和 密码 连接邮件服务器 // 这里认证的邮箱必须与 message 中的发件人邮箱一致，否则报错 transport.connect(myEmailAccount, myEmailPassword); // 6. 发送邮件, 发到所有的收件地址, message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, // 抄送人, 密送人 transport.sendMessage(message, message.getAllRecipients()); // 7. 关闭连接 transport.close(); &#125; /** * 创建一封复杂邮件（文本+图片+附件） */ public static MimeMessage createMimeMessage(Session session, String sendMail, String receiveMail, String receiveMailCc) throws Exception &#123; // 1. 创建邮件对象 MimeMessage message = new MimeMessage(session); // 2. From: 发件人 message.setFrom(new InternetAddress(sendMail, &quot;t-mac&quot;, &quot;UTF-8&quot;)); // 3. To: 收件人（可以增加多个收件人、抄送、密送） message.addRecipient(RecipientType.TO, new InternetAddress(receiveMail, &quot;yao&quot;, &quot;UTF-8&quot;)); message.addRecipient(RecipientType.CC, new InternetAddress( receiveMailCc, &quot;yaoming&quot;, &quot;UTF-8&quot;)); // 4. Subject: 邮件主题 message.setSubject(&quot;TEST邮件主题（文本+图片+附件）&quot;, &quot;UTF-8&quot;); // 添加文本 MimeBodyPart htmlPart = new MimeBodyPart(); htmlPart.setContent( &quot;hahahahh&quot;,&quot;text/html;charset=UTF-8&quot;); /* * 下面是邮件内容的创建: */ // 9. 创建附件“节点” MimeBodyPart attachment = new MimeBodyPart(); DataHandler dh2 = new DataHandler(new FileDataSource( &quot;E:\\test\\NewTest\\Download.CSV&quot;)); // 读取本地文件 attachment.setDataHandler(dh2); // 将附件数据添加到“节点” attachment.setFileName(MimeUtility.encodeText(dh2.getName())); // 设置附件的文件名（需要编码） // 10. 设置（文本+图片）和 附件 的关系（合成一个大的混合“节点” / Multipart ） MimeMultipart mm = new MimeMultipart(); mm.addBodyPart(htmlPart); mm.addBodyPart(attachment); // 如果有多个附件，可以创建多个多次添加 mm.setSubType(&quot;mixed&quot;); // 混合关系 // 11. 设置整个邮件的关系（将最终的混合“节点”作为邮件的内容添加到邮件对象） message.setContent(mm); // 12. 设置发件时间 message.setSentDate(new Date()); // message.setText(&quot;保存上面的所有设置&quot;);// 设置文本内容 // 13. 保存上面的所有设置 message.saveChanges(); return message; &#125;&#125; 四、Python发送邮件 终于来到了Python，不多说，直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164# -*- coding: utf-8 -*-&apos;&apos;&apos;发送邮件&apos;&apos;&apos;import smtplibfrom email.mime.base import MIMEBasefrom email.mime.multipart import MIMEMultipartfrom email.mime.text import MIMETextimport os.pathimport emailimport mimetypesimport osfrom os.path import join, getsizeimport tracebackclass EmailManager: &apos;&apos;&apos; send email to the given email address automatically &apos;&apos;&apos; def __init__(self, **kw): &apos; 构造函数 &apos; self.kw = kw # self.smtp_server = &quot;smtp.exmail.qq.com&quot; self.MAX_FILE_SIZE = 10 * 1024 * 1024 # 10M def run(self): # 总入口 try: # 初始化 self.__my_init() # 登录SMTP服务器，验证授权 server = self.get_login_server() # 生成邮件主体内容 main_msg = self.get_main_msg() # 生成邮件附件内容 file_msg = self.get_attach_file_msg() if file_msg is not None: main_msg.attach(file_msg) # 得到格式化后的完整文本 fullText = main_msg.as_string() # 发送邮件 server.sendmail(self.msg_from, self.receiver, fullText) except Exception as e: print(e) exstr = traceback.format_exc() print(exstr) server.quit() exit() def get_main_msg(self): &apos; 生成邮件主体内容 &apos; # 构造MIMEMultipart对象做为根容器 main_msg = MIMEMultipart() # 构造MIMEText对象做为邮件显示内容并附加到根容器 text_msg = MIMEText(self.msg_content, _charset=&quot;utf-8&quot;) main_msg.attach(text_msg) # 设置根容器属性 main_msg[&apos;From&apos;] = self.msg_from main_msg[&apos;To&apos;] = self.msg_to main_msg[&apos;Cc&apos;] = self.msg_cc main_msg[&apos;Subject&apos;] = self.msg_subject main_msg[&apos;Date&apos;] = self.msg_date return main_msg def get_attach_file_msg(self): &apos; 生成邮件附件内容 &apos; if self.attach_file is not None and self.attach_file != &quot;&quot;: try: self.validate_file_size() data = open(self.attach_file, &apos;rb&apos;) ctype, encoding = mimetypes.guess_type(self.attach_file) if ctype is None or encoding is not None: ctype = &apos;application/octet-stream&apos; maintype, subtype = ctype.split(&apos;/&apos;, 1) file_msg = MIMEBase(maintype, subtype) file_msg.set_payload(data.read()) data.close() email.encoders.encode_base64(file_msg) # 把附件编码 ## 设置附件头 basename = os.path.basename(self.attach_file) file_msg.add_header(&apos;Content-Disposition&apos;, &apos;attachment&apos;, filename=basename) # 修改邮件头 return file_msg except Exception as e: print(e) return None else: return None def get_login_server(self): &apos; 登录SMTP服务器，验证授权信息 &apos; server = smtplib.SMTP(self.smtp_server) server.login(self.server_username, self.server_pwd) # 仅smtp服务器需要验证时 return server def validate_file_size(self): &apos; 验证文件大小是否合法 &apos; if getsize(self.attach_file) &gt; self.MAX_FILE_SIZE: raise Exception(u&apos;附件过大，上传失败&apos;) def __my_init(self): &apos; 配置初始化 &apos; # 邮箱登录设置 self.smtp_server = self.__get_cfg(&apos;smtp_server&apos;) self.server_username = self.__get_cfg(&apos;server_username&apos;) self.server_pwd = self.__get_cfg(&apos;server_pwd&apos;) # 邮件内容设置 self.receiver = self.__get_cfg(&apos;msg_to&apos;) + self.__get_cfg(&apos;msg_cc&apos;) self.msg_from = self.server_username self.msg_to = &apos;,&apos;.join(self.__get_cfg(&apos;msg_to&apos;)) self.msg_cc = &apos;,&apos;.join(self.__get_cfg(&apos;msg_cc&apos;)) self.msg_subject = self.__get_cfg(&apos;msg_subject&apos;) self.msg_date = self.__get_cfg(&apos;msg_date&apos;) print(self.msg_date) self.msg_content = self.__get_cfg(&apos;msg_content&apos;) # 附件 self.attach_file = self.__get_cfg(&apos;attach_file&apos;, throw=False) def __get_cfg(self, key, throw=True): &apos; 根据key从**kw中取得相应的配置内容 &apos; cfg = self.kw.get(key) if throw == True and (cfg is None or cfg == &apos;&apos;): raise Exception(&quot;配置不能为空！&quot;.decode(&apos;utf-8&apos;)) return cfg以下为调用代码：mail_cfg = &#123; # 邮箱登录设置，使用SMTP登录 &apos;server_username&apos;: &apos;czhou@sfcservice.com&apos;, &apos;server_pwd&apos;: &apos;密码&apos;, &apos;smtp_server&apos;: &apos;smtp.exmail.qq.com&apos;, # 邮件内容设置 &apos;msg_to&apos;: [&apos;czhou@sfcservice.com&apos;], # 可以在此添加收件人,一定要list类型 &apos;msg_cc&apos;: [&apos;zone_c@qq.com&apos;, &apos;13026162269@163.com&apos;], &apos;msg_subject&apos;: u&apos;代码&apos;, &apos;msg_date&apos;: time.strftime(&apos;%Y-%m-%d %X&apos;, time.localtime()), &apos;msg_content&apos;: u&quot;我的备份&quot;, # 附件 &apos;attach_file&apos;: &apos;E:\\test\\NewTest\\test.txt&apos;&#125;# print( time.strftime(&apos;%Y-%m-%d %X&apos;, time.localtime()))email_manager = EmailManager(**mail_cfg)email_manager.run()]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[测试文章]]></title>
      <url>%2F2016%2F09%2F03%2Fhexo-test%2F</url>
      <content type="text"><![CDATA[biaotibaagaagar]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2016%2F09%2F01%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
